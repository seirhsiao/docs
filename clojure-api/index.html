

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Clojure API 文档</title>
  

  
  

  

  
  
    

  

  
  

  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  
    <link rel="stylesheet" href="https://media.readthedocs.org/css/readthedocs-doc-embed.css" type="text/css" />
  

  
    <link rel="top" title="None" href="index.html#document-index"/>
 
<!-- RTD Extra Head -->

    

<!-- 
Always link to the latest version, as canonical.
http://docs.readthedocs.org/en/latest/canonical.html
-->
<link rel="canonical" href="http://clojure-api-zh.readthedocs.org/zh_CN/latest/" />
<script type="text/javascript">
  // This is included here because other places don't have access to the pagename variable.
  var READTHEDOCS_DATA = {
    project: "clojure-api-zh",
    version: "latest",
    language: "zh_CN",
    page: "index",
    builder: "sphinx",
    theme: "sphinx_rtd_theme",
    docroot: "/./",
    
    source_suffix: ".rst",
    
    api_host: "https://readthedocs.org/",
    commit: "300c8b65"
  }
  // Old variables
  var doc_version = "latest";
  var doc_slug = "clojure-api-zh";
  var page_name = "index";
  var html_theme = "sphinx_rtd_theme";
</script>
<!-- RTD Analytics Code -->
<!-- Included in the header because you don't have a footer block. -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  // User Analytics Code
  _gaq.push(['user._setAccount', 'None']);
  _gaq.push(['user._trackPageview']);
  // End User Analytics Code


  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
<!-- end RTD Analytics Code -->
<!-- end RTD <extrahead> -->


  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html#document-index" class="icon icon-home"> Clojure API 文档
          

          
          </a>

          
            
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.core/index">clojure.core</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.core.async/index">clojure.core.async</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.data/index">clojure.data</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.pprint/index">clojure.pprint</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.string/index">clojure.string</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.set/ind">clojure.set</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.test/index">clojure.test</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.java.browse/index">clojure.java.browse</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.java.io/index">clojure.java.io</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.java.javadoc/index">clojure.java.javadoc</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.java.shell/index">clojure.java.shell</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.xml/index">clojure.xml</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-clojure.repl/index">clojure.repl</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html#document-index">Clojure API 文档</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html#document-index">Docs</a> &raquo;</li>
      
    <li>Clojure API 文档</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="https://github.com/seirhsiao/clojure_api_cn/blob/master/./index.rst" class="fa fa-github"> Edit on GitHub</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="clojure-api">
<h1>Clojure API 文档<a class="headerlink" href="#clojure-api" title="永久链接至标题">¶</a></h1>
<img alt="_images/clojure-icon.gif" class="align-right" src="_images/clojure-icon.gif" />
<p>这是 Clojure 官方 API 文档
<a class="reference external" href="http://clojure.github.com/clojure/">clojure.github.com/clojure</a>
的中文翻译版本。</p>
<p>翻译工作目前正在进行中，欢迎加入：
<a class="reference external" href="https://github.com/huangz1990/clojure_api_cn">github.com/huangz1990/clojure_api_cn</a>
。</p>
<p><strong>目录：</strong></p>
<div class="toctree-wrapper compound">
<span id="document-clojure.core/index"></span><div class="section" id="clojure-core">
<h2>clojure.core<a class="headerlink" href="#clojure-core" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.core/->"></span><div class="section" id="id1">
<h3>-&gt;<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(-&gt; x)</strong></div>
<div class="line"><strong>(-&gt; x form)</strong></div>
<div class="line"><strong>(-&gt; x form &amp; more)</strong></div>
</div>
<p>将多个形式串连成一个表达式。</p>
<p>如果只有一个参数 <code class="docutils literal"><span class="pre">x</span></code> 和一个形式 <code class="docutils literal"><span class="pre">form</span></code> ，那么将 <code class="docutils literal"><span class="pre">x</span></code> 作为第二个项(item)，插入到 <code class="docutils literal"><span class="pre">form</span></code> 当中，如果 <code class="docutils literal"><span class="pre">form</span></code> 不是一个列表，那么将 <code class="docutils literal"><span class="pre">form</span></code> 包裹到一个列表里面。[译注：举个例子， <code class="docutils literal"><span class="pre">(-&gt;</span> <span class="pre">a-map</span> <span class="pre">:key)</span></code> 会展开成 <code class="docutils literal"><span class="pre">(:key</span> <span class="pre">a-map)</span></code> ，而不是 <code class="docutils literal"><span class="pre">:key</span> <span class="pre">a-map</span></code> 。]</p>
<p>如果有多于一个形式，那么将第一个形式作为第二个项插入到第二个形式中，以此类推。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L1529">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 应用多个函数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="s">&quot;a b c d&quot;</span> <span class="nv">.toUpperCase</span> <span class="p">(</span><span class="nf">.replace</span> <span class="s">&quot;A&quot;</span> <span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">.split</span> <span class="s">&quot; &quot;</span><span class="p">)</span> <span class="nv">first</span><span class="p">)</span>
<span class="s">&quot;X&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.walk</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">macroexpand-all</span><span class="p">]])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">macroexpand-all</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">-&gt; </span><span class="s">&quot;a b c d&quot;</span>
                             <span class="nv">.toUpperCase</span>
                             <span class="p">(</span><span class="nf">.replace</span> <span class="s">&quot;A&quot;</span> <span class="s">&quot;X&quot;</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">.split</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
                             <span class="nv">first</span><span class="p">))</span>
<span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="k">. </span><span class="p">(</span><span class="k">. </span><span class="p">(</span><span class="k">. </span><span class="s">&quot;a b c d&quot;</span> <span class="nv">toUpperCase</span><span class="p">)</span> <span class="nb">replace </span><span class="s">&quot;A&quot;</span> <span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="nv">split</span> <span class="s">&quot; &quot;</span><span class="p">))</span>

<span class="c1">; 从深层嵌套的 map 中取出值</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">language</span> <span class="p">{</span><span class="ss">:clojure</span> <span class="p">{</span><span class="ss">:author</span> <span class="p">{</span><span class="ss">:first-name</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:last-name</span> <span class="s">&quot;Hickey&quot;</span><span class="p">}}})</span>
<span class="o">#</span><span class="ss">&#39;user/language</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="ss">:first-name</span> <span class="p">(</span><span class="ss">:author</span> <span class="p">(</span><span class="ss">:clojure</span> <span class="nv">language</span><span class="p">)))</span>
<span class="s">&quot;Rich&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">language</span> <span class="ss">:clojure</span> <span class="ss">:author</span> <span class="ss">:first-name</span><span class="p">)</span>
<span class="s">&quot;Rich&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/->>"></span><div class="section" id="id1">
<h3>-&gt;&gt;<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(-&gt;&gt; x form)</strong></div>
<div class="line"><strong>(-&gt;&gt; x form &amp; more)</strong></div>
</div>
<p>将多个形式串连成一个表达式。</p>
<p>如果只有一个参数 <code class="docutils literal"><span class="pre">x</span></code> 和一个形式 <code class="docutils literal"><span class="pre">form</span></code> ，那么将 <code class="docutils literal"><span class="pre">x</span></code> 作为最后一项(item)，插入到 <code class="docutils literal"><span class="pre">form</span></code> 当中，如果 <code class="docutils literal"><span class="pre">form</span></code> 不是一个列表，那么将 <code class="docutils literal"><span class="pre">form</span></code> 包裹到一个列表里面。[译注：举个例子， <code class="docutils literal"><span class="pre">(-&gt;&gt;</span> <span class="pre">a-map</span> <span class="pre">:key)</span></code> 会展开成 <code class="docutils literal"><span class="pre">(:key</span> <span class="pre">a-map)</span></code> ，而不是 <code class="docutils literal"><span class="pre">:key</span> <span class="pre">a-map</span></code> 。]</p>
<p>如果有多于一个形式，那么将第一个形式作为最后一项插入到第二个形式中，以此类推。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L1541">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 计算小于 10 的整数的平方之和</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">range</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">take </span><span class="mi">10</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))</span>
<span class="mi">1140</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.walk</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">macroexpand-all</span><span class="p">]])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">macroexpand-all</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">range</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">))</span>
                              <span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">take </span><span class="mi">10</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">reduce + </span><span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nf">fn*</span> <span class="p">[</span><span class="nv">p1__3#</span><span class="p">]</span> <span class="p">(</span><span class="nb">* </span><span class="nv">p1__3#</span> <span class="nv">p1__3#</span><span class="p">))</span> <span class="p">(</span><span class="nf">range</span><span class="p">)))))</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/-_"></span><div class="section" id="id1">
<h3>-&gt;<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(-&gt; x)</strong></div>
<div class="line"><strong>(-&gt; x form)</strong></div>
<div class="line"><strong>(-&gt; x form &amp; more)</strong></div>
</div>
<p>将多个形式串连成一个表达式。</p>
<p>如果只有一个参数 <code class="docutils literal"><span class="pre">x</span></code> 和一个形式 <code class="docutils literal"><span class="pre">form</span></code> ，那么将 <code class="docutils literal"><span class="pre">x</span></code> 作为第二个项(item)，插入到 <code class="docutils literal"><span class="pre">form</span></code> 当中，如果 <code class="docutils literal"><span class="pre">form</span></code> 不是一个列表，那么将 <code class="docutils literal"><span class="pre">form</span></code> 包裹到一个列表里面。[译注：举个例子， <code class="docutils literal"><span class="pre">(-&gt;</span> <span class="pre">a-map</span> <span class="pre">:key)</span></code> 会展开成 <code class="docutils literal"><span class="pre">(:key</span> <span class="pre">a-map)</span></code> ，而不是 <code class="docutils literal"><span class="pre">:key</span> <span class="pre">a-map</span></code> 。]</p>
<p>如果有多于一个形式，那么将第一个形式作为第二个项插入到第二个形式中，以此类推。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L1529">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 应用多个函数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="s">&quot;a b c d&quot;</span> <span class="nv">.toUpperCase</span> <span class="p">(</span><span class="nf">.replace</span> <span class="s">&quot;A&quot;</span> <span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">.split</span> <span class="s">&quot; &quot;</span><span class="p">)</span> <span class="nv">first</span><span class="p">)</span>
<span class="s">&quot;X&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.walk</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">macroexpand-all</span><span class="p">]])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">macroexpand-all</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">-&gt; </span><span class="s">&quot;a b c d&quot;</span>
                             <span class="nv">.toUpperCase</span>
                             <span class="p">(</span><span class="nf">.replace</span> <span class="s">&quot;A&quot;</span> <span class="s">&quot;X&quot;</span><span class="p">)</span>
                             <span class="p">(</span><span class="nf">.split</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
                             <span class="nv">first</span><span class="p">))</span>
<span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="k">. </span><span class="p">(</span><span class="k">. </span><span class="p">(</span><span class="k">. </span><span class="s">&quot;a b c d&quot;</span> <span class="nv">toUpperCase</span><span class="p">)</span> <span class="nb">replace </span><span class="s">&quot;A&quot;</span> <span class="s">&quot;X&quot;</span><span class="p">)</span> <span class="nv">split</span> <span class="s">&quot; &quot;</span><span class="p">))</span>

<span class="c1">; 从深层嵌套的 map 中取出值</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">language</span> <span class="p">{</span><span class="ss">:clojure</span> <span class="p">{</span><span class="ss">:author</span> <span class="p">{</span><span class="ss">:first-name</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:last-name</span> <span class="s">&quot;Hickey&quot;</span><span class="p">}}})</span>
<span class="o">#</span><span class="ss">&#39;user/language</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="ss">:first-name</span> <span class="p">(</span><span class="ss">:author</span> <span class="p">(</span><span class="ss">:clojure</span> <span class="nv">language</span><span class="p">)))</span>
<span class="s">&quot;Rich&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">-&gt; </span><span class="nv">language</span> <span class="ss">:clojure</span> <span class="ss">:author</span> <span class="ss">:first-name</span><span class="p">)</span>
<span class="s">&quot;Rich&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/-__"></span><div class="section" id="id1">
<h3>-&gt;&gt;<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(-&gt;&gt; x form)</strong></div>
<div class="line"><strong>(-&gt;&gt; x form &amp; more)</strong></div>
</div>
<p>将多个形式串连成一个表达式。</p>
<p>如果只有一个参数 <code class="docutils literal"><span class="pre">x</span></code> 和一个形式 <code class="docutils literal"><span class="pre">form</span></code> ，那么将 <code class="docutils literal"><span class="pre">x</span></code> 作为最后一项(item)，插入到 <code class="docutils literal"><span class="pre">form</span></code> 当中，如果 <code class="docutils literal"><span class="pre">form</span></code> 不是一个列表，那么将 <code class="docutils literal"><span class="pre">form</span></code> 包裹到一个列表里面。[译注：举个例子， <code class="docutils literal"><span class="pre">(-&gt;&gt;</span> <span class="pre">a-map</span> <span class="pre">:key)</span></code> 会展开成 <code class="docutils literal"><span class="pre">(:key</span> <span class="pre">a-map)</span></code> ，而不是 <code class="docutils literal"><span class="pre">:key</span> <span class="pre">a-map</span></code> 。]</p>
<p>如果有多于一个形式，那么将第一个形式作为最后一项插入到第二个形式中，以此类推。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L1541">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 计算小于 10 的整数的平方之和</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">range</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">take </span><span class="mi">10</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">))</span>
<span class="mi">1140</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.walk</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">macroexpand-all</span><span class="p">]])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">macroexpand-all</span> <span class="o">&#39;</span><span class="p">(</span><span class="nf">-&gt;&gt;</span> <span class="p">(</span><span class="nf">range</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">* </span><span class="nv">%</span> <span class="nv">%</span><span class="p">))</span>
                              <span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">take </span><span class="mi">10</span><span class="p">)</span>
                              <span class="p">(</span><span class="nb">reduce </span><span class="nv">+</span><span class="p">)))</span>
<span class="p">(</span><span class="nb">reduce + </span><span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="nf">fn*</span> <span class="p">[</span><span class="nv">p1__3#</span><span class="p">]</span> <span class="p">(</span><span class="nb">* </span><span class="nv">p1__3#</span> <span class="nv">p1__3#</span><span class="p">))</span> <span class="p">(</span><span class="nf">range</span><span class="p">)))))</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/aclone"></span><div class="section" id="aclone">
<h3>aclone<a class="headerlink" href="#aclone" title="永久链接至标题">¶</a></h3>
<p><strong>(aclone array)</strong></p>
<p>返回Java数组的克隆，作用于已知类型的数组</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">a</span> <span class="p">(</span><span class="nf">int-array</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]))</span>
<span class="o">#</span><span class="ss">&#39;user/a</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">b</span> <span class="p">(</span><span class="nf">aclone</span> <span class="nv">a</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/b</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">aset </span><span class="nv">b</span> <span class="mi">0</span> <span class="mi">23</span><span class="p">)</span>
<span class="mi">23</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">vec</span> <span class="nv">b</span><span class="p">)</span>
<span class="p">[</span><span class="mi">23</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">vec</span> <span class="nv">a</span><span class="p">)</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/alength"></span><div class="section" id="alength">
<h3>alength<a class="headerlink" href="#alength" title="永久链接至标题">¶</a></h3>
<p><strong>(alength array)</strong></p>
<p>返回Java数组长度,作用于所有类型</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="k">def </span><span class="nv">array</span> <span class="p">(</span><span class="nb">into-array </span><span class="nv">Integer/TYPE</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]))</span>
<span class="o">#</span><span class="ss">&#39;user/array</span>

<span class="p">(</span><span class="nb">alength </span><span class="nv">array</span><span class="p">)</span>
<span class="mi">5</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/alter-var-root"></span><div class="section" id="alter-var-root">
<h3>alter-var-root<a class="headerlink" href="#alter-var-root" title="永久链接至标题">¶</a></h3>
<p><strong>(alter-var-root v f &amp; args)</strong></p>
<p>原子性地修改 var <code class="docutils literal"><span class="pre">v</span></code> 的值，新值由 <code class="docutils literal"><span class="pre">v</span></code> 的旧值和给定的 <code class="docutils literal"><span class="pre">args</span></code> 应用到函数 <code class="docutils literal"><span class="pre">f</span></code> 得出。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L4834">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">v</span> <span class="mi">10</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/v</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">alter-var-root</span> <span class="p">(</span><span class="k">var </span><span class="nv">v</span><span class="p">)</span> <span class="nb">+ </span><span class="mi">1</span><span class="p">)</span>     <span class="c1">; (var v) 等同于 #&#39;v</span>
<span class="mi">11</span>

<span class="nv">user=&gt;</span> <span class="nv">v</span>
<span class="mi">11</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/assoc"></span><div class="section" id="assoc">
<h3>assoc<a class="headerlink" href="#assoc" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(assoc map key val)</strong></div>
<div class="line"><strong>(assoc map key val &amp; kvs)</strong></div>
</div>
<p>assoc 表示 associate 的意思。</p>
<p><code class="docutils literal"><span class="pre">assoc</span></code> 接受一个 Map ，还有一个或多个 <code class="docutils literal"><span class="pre">key-val</span></code> 对，
返回一个和传入 Map 类型相同的新 Map ，
除了原来传入 Map 已有的数据外，
新 Map 还包含传给 <code class="docutils literal"><span class="pre">assoc</span></code> 的那些 <code class="docutils literal"><span class="pre">key-val</span></code> 对。</p>
<p>当一个向量被应用到 <code class="docutils literal"><span class="pre">assoc</span></code> 函数时，
返回一个新向量，
新向量的索引下标（index） <code class="docutils literal"><span class="pre">key</span></code> 的值就是 <code class="docutils literal"><span class="pre">val</span></code> 。</p>
<p>注意索引下标必须 <code class="docutils literal"><span class="pre">&lt;=</span> <span class="pre">(count</span> <span class="pre">vector)</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">assoc </span><span class="p">{}</span> <span class="ss">:Clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:Clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">assoc </span><span class="p">{</span><span class="ss">:Clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">}</span> <span class="ss">:Clojure</span> <span class="s">&quot;Rich Hickey&quot;</span><span class="p">)</span>     <span class="c1">; 如果有同名 key ，那么那么覆盖它</span>
<span class="p">{</span><span class="ss">:Clojure</span> <span class="s">&quot;Rich Hickey&quot;</span><span class="p">}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">assoc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">0</span> <span class="mi">10086</span><span class="p">)</span>
<span class="p">[</span><span class="mi">10086</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">assoc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">3</span> <span class="mi">10086</span><span class="p">)</span>          <span class="c1">; key 最大可以等于 (count vector)</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">10086</span><span class="p">]</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">assoc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="mi">10086</span> <span class="mi">10086</span><span class="p">)</span>      <span class="c1">; key 不能大于 (count vector)</span>
<span class="nv">IndexOutOfBoundsException</span>   <span class="nv">clojure.lang.PersistentVector.assocN</span>
<span class="p">(</span><span class="nf">PersistentVector.java</span><span class="ss">:136</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/bigdec"></span><div class="section" id="bigdec">
<h3>bigdec<a class="headerlink" href="#bigdec" title="永久链接至标题">¶</a></h3>
<p><strong>(bigdec x)</strong></p>
<p>将 <code class="docutils literal"><span class="pre">x</span></code> 强制转换为 <code class="docutils literal"><span class="pre">BigDecimal</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/c6756a8bab137128c8119add29a25b0a88509900/src/clj/clojure/core.clj#L3295">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">bigdec</span> <span class="mf">3.0</span><span class="p">)</span>
<span class="mf">3.0</span><span class="nv">M</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">bigdec</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">5</span><span class="nv">M</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">bigdec</span> <span class="mi">-1</span><span class="p">)</span>
<span class="mi">-1</span><span class="nv">M</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">bigdec</span> <span class="mf">-1.0</span><span class="p">)</span>
<span class="mf">-1.0</span><span class="nv">M</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/bigint"></span><div class="section" id="bigint">
<h3>bigint<a class="headerlink" href="#bigint" title="永久链接至标题">¶</a></h3>
<p><strong>(bigint x)</strong></p>
<p>将 <code class="docutils literal"><span class="pre">x</span></code> 强制转换为 <code class="docutils literal"><span class="pre">BigInt</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/c6756a8bab137128c8119add29a25b0a88509900/src/clj/clojure/core.clj#L3269">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nf">biginteger</span> <span class="mi">19931029</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">class </span><span class="nv">x</span><span class="p">)</span>
<span class="nv">java.math.BigInteger</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/biginteger"></span><div class="section" id="biginteger">
<h3>biginteger<a class="headerlink" href="#biginteger" title="永久链接至标题">¶</a></h3>
<p><strong>(biginteger x)</strong></p>
<p>将 <code class="docutils literal"><span class="pre">x</span></code> 强制转换为 <code class="docutils literal"><span class="pre">BigInteger</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/c6756a8bab137128c8119add29a25b0a88509900/src/clj/clojure/core.clj#L3282">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">x</span> <span class="p">(</span><span class="nf">biginteger</span> <span class="mi">19931029</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/x</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">class </span><span class="nv">x</span><span class="p">)</span>
<span class="nv">java.math.BigInteger</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/comment"></span><div class="section" id="comment">
<h3>comment<a class="headerlink" href="#comment" title="永久链接至标题">¶</a></h3>
<p><strong>(comment &amp; body)</strong></p>
<p>忽略 <code class="docutils literal"><span class="pre">body</span></code> ，返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L4165">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">comment </span><span class="nv">hello-clojure</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">comment </span><span class="s">&quot;clojure!&quot;</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">msg</span> <span class="p">[]</span>
         <span class="p">(</span><span class="nb">comment </span><span class="s">&quot;nothing but a greeting message here&quot;</span><span class="p">)</span>
         <span class="p">(</span><span class="nb">println </span><span class="s">&quot;hello&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/msg</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">msg</span><span class="p">)</span>
<span class="nv">hello</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/comp"></span><div class="section" id="comp">
<h3>comp<a class="headerlink" href="#comp" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(comp)</strong></div>
<div class="line"><strong>(comp f)</strong></div>
<div class="line"><strong>(comp f g)</strong></div>
<div class="line"><strong>(comp f g h)</strong></div>
<div class="line"><strong>(comp f g h &amp; other-functions)</strong></div>
</div>
<p><code class="docutils literal"><span class="pre">comp</span></code> 接受一系列函数作为输入，
返回一个匿名函数。</p>
<p>这个匿名函数接受可变数量的参数（variable number of args），
并按从右到左的顺序，
将传入的函数应用到参数中。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">((</span><span class="nb">comp str double </span><span class="nv">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1">; 以下两个表达等价</span>
<span class="s">&quot;9.0&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nb">double </span><span class="p">(</span><span class="nb">+ </span><span class="mi">3</span> <span class="mi">3</span> <span class="mi">3</span><span class="p">)))</span>
<span class="s">&quot;9.0&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/compile"></span><div class="section" id="compile">
<h3>compile<a class="headerlink" href="#compile" title="永久链接至标题">¶</a></h3>
<p><strong>(compile lib)</strong></p>
<p>编译符号(symbol) <code class="docutils literal"><span class="pre">lib</span></code> 定义的命名空间到一系列的class文件。 <code class="docutils literal"><span class="pre">lib</span></code> 的源文件必须在正确的类关联(classpath-relative)的目录下，输出的文class文件将会在 <code class="docutils literal"><span class="pre">*compile-path*</span></code> 定义的目录里，这个目录也必须在类路径(classpath)里面。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/c6756a8bab137128c8119add29a25b0a88509900/src/clj/clojure/core.clj#L5532">查看源码</a></p>
</div>
<span id="document-clojure.core/complement"></span><div class="section" id="complement">
<h3>complement<a class="headerlink" href="#complement" title="永久链接至标题">¶</a></h3>
<p><strong>(complement f)</strong></p>
<p>接受一个函数 <code class="docutils literal"><span class="pre">f</span></code> ，返回一个匿名函数。</p>
<p>这个匿名函数接受的参数、产生的作用都和 <code class="docutils literal"><span class="pre">f</span></code> 一样，
但它返回的真值和 <code class="docutils literal"><span class="pre">f</span></code> 相反。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">f</span> <span class="p">[]</span>
           <span class="p">(</span><span class="nb">println </span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
           <span class="nv">false</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/f</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">f</span><span class="p">)</span>
<span class="nv">hello</span>
<span class="nv">false</span>

<span class="nv">user=&gt;</span> <span class="p">((</span><span class="nb">complement </span><span class="nv">f</span><span class="p">))</span>
<span class="nv">hello</span>
<span class="nv">true</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/concat"></span><div class="section" id="concat">
<h3>concat<a class="headerlink" href="#concat" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(concat)</strong></div>
<div class="line"><strong>(concat x)</strong></div>
<div class="line"><strong>(concat x y)</strong></div>
<div class="line"><strong>(concat x y &amp; zs)</strong></div>
</div>
<p>返回一个惰性序列，序列里包含所有传入 collection 的全部元素。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 另个、一个或多个 collection 组合</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">concat</span><span class="p">)</span>
<span class="p">()</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">concat </span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">concat </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">concat </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">concat </span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">)</span>


<span class="c1">; 传入 concat 的参数必须都是 collection</span>
<span class="c1">; 组合元素和 collection 是 cons 和 conj 的任务</span>

<span class="c1">; user=&gt; (concat 1 [2 3])</span>
<span class="c1">; IllegalArgumentException Don&#39;t know how to create ISeq from: java.lang.Long  clojure.lang.RT.seqFrom (RT.java:487)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/cond"></span><div class="section" id="cond">
<h3>cond<a class="headerlink" href="#cond" title="永久链接至标题">¶</a></h3>
<p><strong>(cond &amp; clauses)</strong></p>
<p>接受一系列 <code class="docutils literal"><span class="pre">test</span></code>/<code class="docutils literal"><span class="pre">expression</span></code> 对，
它每次对一个 <code class="docutils literal"><span class="pre">test</span></code> 进行求值，
如果某个 <code class="docutils literal"><span class="pre">test</span></code> 返回 <code class="docutils literal"><span class="pre">true</span></code> ，
那么 <code class="docutils literal"><span class="pre">cond</span></code> 求值并返回与这个 <code class="docutils literal"><span class="pre">test</span></code> 相对应的 <code class="docutils literal"><span class="pre">expression</span></code> ，
并且不再对其他 <code class="docutils literal"><span class="pre">test</span></code> 进行求值。</p>
<p><code class="docutils literal"><span class="pre">(cond)</span></code> 返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">type-of-number</span> <span class="p">[</span><span class="nv">n</span><span class="p">]</span>
           <span class="p">(</span><span class="nb">cond </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&quot;positive number&quot;</span>
                 <span class="p">(</span><span class="nb">&lt; </span><span class="nv">n</span> <span class="mi">0</span><span class="p">)</span> <span class="s">&quot;negative number&quot;</span>
                 <span class="ss">:else</span> <span class="s">&quot;zero&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/type-of-number</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type-of-number</span> <span class="mi">10</span><span class="p">)</span>
<span class="s">&quot;positive number&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type-of-number</span> <span class="mi">-5</span><span class="p">)</span>
<span class="s">&quot;negative number&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">type-of-number</span> <span class="mi">0</span><span class="p">)</span>
<span class="s">&quot;zero&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/conj"></span><div class="section" id="conj">
<h3>conj<a class="headerlink" href="#conj" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(conj coll x)</strong></div>
<div class="line"><strong>(conj coll x &amp; xs)</strong></div>
</div>
<p><code class="docutils literal"><span class="pre">conj</span></code> 的完整词义是 conjoin ，
表示『相连接』的意思，
它用于将元素和 collection 拼接起来。</p>
<p>需要注意的是，
根据 <code class="docutils literal"><span class="pre">coll</span></code> 的类型，
组合会发生在 <code class="docutils literal"><span class="pre">coll</span></code> 的不同地方，
也即是， 元素 <code class="docutils literal"><span class="pre">x</span></code> 可能会被加入到 <code class="docutils literal"><span class="pre">coll</span></code> 的最左边，也可能会被加入到最右边。</p>
<p>当 <code class="docutils literal"><span class="pre">coll</span></code> 等于 <code class="docutils literal"><span class="pre">nil</span></code> ，
也即是，执行 <code class="docutils literal"><span class="pre">(conj</span> <span class="pre">nil</span> <span class="pre">item)</span></code> 时，
结果为 <code class="docutils literal"><span class="pre">(item)</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; coll 为 nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">conj </span><span class="nv">nil</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="c1">; 向量的组合在尾部进行</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>


<span class="c1">; 列表的组合在头部进行</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">list </span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>


<span class="c1">; 处理多个元素的 conj</span>
<span class="c1">; 注意向量和列表的结果之间的不同</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">conj </span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">conj </span><span class="p">(</span><span class="nb">list </span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/cons"></span><div class="section" id="cons">
<h3>cons<a class="headerlink" href="#cons" title="永久链接至标题">¶</a></h3>
<p><strong>(cons x seq)</strong></p>
<p>返回一个新的序列，
序列的第一个元素是 <code class="docutils literal"><span class="pre">x</span></code> ，
而 <code class="docutils literal"><span class="pre">seq</span></code> 则是序列的其余部分。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; cons 起数字 1 和空列表</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="c1">; cons 起数字 1 和列表 (2 3)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">cons </span><span class="mi">1</span> <span class="p">(</span><span class="nb">list </span><span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/constantly"></span><div class="section" id="constantly">
<h3>constantly<a class="headerlink" href="#constantly" title="永久链接至标题">¶</a></h3>
<p><strong>(constantly x)</strong></p>
<p>返回一个匿名函数，
接受任何数量的参数，
但总是返回 <code class="docutils literal"><span class="pre">x</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">ten</span> <span class="p">(</span><span class="nb">constantly </span><span class="mi">10</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/ten</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">ten</span><span class="p">)</span>
<span class="mi">10</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">ten</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">10</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">ten</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="mi">10</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">ten</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">10</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/contains"></span><div class="section" id="contains">
<h3>contains?<a class="headerlink" href="#contains" title="永久链接至标题">¶</a></h3>
<p><strong>(contains? coll key)</strong></p>
<p>如果 <code class="docutils literal"><span class="pre">key</span></code> 存在于给定 <code class="docutils literal"><span class="pre">coll</span></code> 中，
那么返回 <code class="docutils literal"><span class="pre">true</span></code> ，否则返回 <code class="docutils literal"><span class="pre">false</span></code> 。</p>
<p>对于那些使用数值索引（index）的 collection 、比如向量和 Java 数组来说，
<code class="docutils literal"><span class="pre">contains?</span></code> 用于测试给定的数值 <code class="docutils literal"><span class="pre">key</span></code> 是否在索引的范围(range)之内。</p>
<p><code class="docutils literal"><span class="pre">contains?</span></code> 不是线性复杂度的操作，
它可以在常数或对数复杂度内完成。</p>
<p>如果要检查一个 <code class="docutils literal"><span class="pre">coll</span></code> 是否符合某个条件，可以使用 <cite>some</cite> 函数。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">contains? </span><span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">}</span> <span class="ss">:python</span><span class="p">)</span>        <span class="c1">; 测试 Map</span>
<span class="nv">false</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">contains? </span><span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">}</span> <span class="ss">:clojure</span><span class="p">)</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">contains? </span><span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">]</span> <span class="mi">3</span><span class="p">)</span>                    <span class="c1">; 测试向量</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">contains? </span><span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">]</span> <span class="mi">10086</span><span class="p">)</span>
<span class="nv">false</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/count"></span><div class="section" id="count">
<h3>count<a class="headerlink" href="#count" title="永久链接至标题">¶</a></h3>
<p><strong>(count coll)</strong></p>
<p>返回 <code class="docutils literal"><span class="pre">coll</span></code> 中元素的数量。</p>
<p><code class="docutils literal"><span class="pre">(count</span> <span class="pre">nil)</span></code> 返回 <code class="docutils literal"><span class="pre">0</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">coll</span></code> 也可以是字符串、数组、Java Collection 和 Map 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">count </span><span class="nv">nil</span><span class="p">)</span>
<span class="mi">0</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">count </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="mi">4</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">count </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="mi">4</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">count </span><span class="s">&quot;string&quot;</span><span class="p">)</span>
<span class="mi">6</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">count </span><span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span> <span class="ss">:ruby</span> <span class="ss">:Matz</span><span class="p">})</span>
<span class="mi">3</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/counted"></span><div class="section" id="counted">
<h3>counted?<a class="headerlink" href="#counted" title="永久链接至标题">¶</a></h3>
<p><strong>(counted? coll)</strong></p>
<p>如果 <code class="docutils literal"><span class="pre">coll</span></code> 实现了常数复杂度的 <code class="docutils literal"><span class="pre">count</span></code> 操作，那么返回 <code class="docutils literal"><span class="pre">true</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 向量、列表、Map 和集合的 count 操作都是常数复杂度的</span>
<span class="c1">; 但字符串不是</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">counted?</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">counted?</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">counted?</span> <span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">})</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">counted?</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">})</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">counted?</span> <span class="s">&quot;string&quot;</span><span class="p">)</span>
<span class="nv">false</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/declare"></span><div class="section" id="declare">
<h3>declare<a class="headerlink" href="#declare" title="永久链接至标题">¶</a></h3>
<p><strong>(declare &amp; names)</strong></p>
<p>定义一些无绑定的 var 名字，用于提前声明（forward declarations）。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">f</span> <span class="p">[]</span>
           <span class="p">(</span><span class="nf">g</span><span class="p">))</span>
<span class="c1">;CompilerException java.lang.RuntimeException: Unable to resolve symbol: g in this context, compiling:(NO_SOURCE_PATH:2)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">declare </span><span class="nv">g</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/g</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">f</span> <span class="p">[]</span>
            <span class="p">(</span><span class="nf">g</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/f</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/defn-"></span><div class="section" id="defn">
<h3>defn-<a class="headerlink" href="#defn" title="永久链接至标题">¶</a></h3>
<p><strong>(defn- name &amp; decls)</strong></p>
<p>作用和 <code class="docutils literal"><span class="pre">defn</span></code> 类似，唯一的不同是创建的函数是私有的。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn- </span><span class="nv">msg</span> <span class="p">[]</span> <span class="s">&quot;hello moto&quot;</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/msg</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">msg</span><span class="p">)</span>
<span class="s">&quot;hello moto&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">meta </span><span class="o">#</span><span class="ss">&#39;msg</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:arglists</span> <span class="p">([])</span>, <span class="ss">:ns</span> <span class="o">#</span><span class="nv">&lt;Namespace</span> <span class="nv">user&gt;</span>, <span class="ss">:name</span> <span class="nv">msg</span>, <span class="ss">:private</span> <span class="nv">true</span>, <span class="ss">:line</span> <span class="mi">1</span>, <span class="ss">:file</span> <span class="s">&quot;NO_SOURCE_PATH&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/defonce"></span><div class="section" id="defonce">
<h3>defonce<a class="headerlink" href="#defonce" title="永久链接至标题">¶</a></h3>
<p><strong>(defonce name expr)</strong></p>
<p>将 <code class="docutils literal"><span class="pre">name</span></code> 的 root value 设置为 <code class="docutils literal"><span class="pre">expr</span></code> 的值，当且仅当 <code class="docutils literal"><span class="pre">name</span></code> 还没有设置 root value 。</p>
<p>如果 <code class="docutils literal"><span class="pre">name</span></code> 已经有 root value ，那么 <code class="docutils literal"><span class="pre">expr</span></code> 不会被求值。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="nv">number</span>                       <span class="c1">; 没有 root value</span>
<span class="c1">;CompilerException java.lang.RuntimeException: Unable to resolve symbol: number in this context, compiling:(NO_SOURCE_PATH:0)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defonce </span><span class="nv">number</span> <span class="mi">10086</span><span class="p">)</span>       <span class="c1">; 设置 root value</span>
<span class="o">#</span><span class="ss">&#39;user/number</span>

<span class="nv">user=&gt;</span> <span class="nv">number</span>
<span class="mi">10086</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defonce </span><span class="nv">number</span> <span class="mi">123123</span><span class="p">)</span>      <span class="c1">; 已有 root value ，设置失败</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="nv">number</span>
<span class="mi">10086</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/defprotocol"></span><div class="section" id="defprotocol">
<h3>defprotocol<a class="headerlink" href="#defprotocol" title="永久链接至标题">¶</a></h3>
<p><strong>(defprotocol name &amp; opts+sigs)</strong></p>
<p>协议是一组命名方法和签名</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="kd">defprotocol </span><span class="nv">IOFactory</span>
  <span class="p">(</span><span class="nf">make-reader</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span> <span class="s">&quot;Create a Buffered Reader&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">make-writer</span> <span class="p">[</span><span class="nv">this</span><span class="p">]</span> <span class="s">&quot;Create a Buffered Writer&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/delay"></span><div class="section" id="delay">
<h3>delay<a class="headerlink" href="#delay" title="永久链接至标题">¶</a></h3>
<p><strong>(delay &amp; body)</strong></p>
<p>参数 <code class="docutils literal"><span class="pre">body</span></code> 接受一系列表达式，并返回一个 <code class="docutils literal"><span class="pre">Delay</span></code> 对象。</p>
<p>这个 <code class="docutils literal"><span class="pre">Delay</span></code> 对象只有在第一次被 <code class="docutils literal"><span class="pre">force</span></code> 函数、 <code class="docutils literal"><span class="pre">deref</span></code> 函数或者 <code class="docutils literal"><span class="pre">&#64;</span></code> 宏强迫求值时，才会对 <code class="docutils literal"><span class="pre">body</span></code> 进行求值。</p>
<p><code class="docutils literal"><span class="pre">body</span></code> 的求值结果会被缓存，之后对这个 <code class="docutils literal"><span class="pre">Delay</span></code> 对象的所有强迫求值，都返回这个缓存结果。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L682">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre>user=&gt; (def d (delay (println &quot;force delay object&quot;)
                     (+ 1 1)))
#&#39;user/d

user=&gt; d
#&lt;Delay@15c5bba: :pending&gt;

user=&gt; @d
force delay object      ; 第一次强迫求值
2                       ; 这个值会被缓存

user=&gt; @d
2                       ; 不再求值 body ，只返回缓存值

user=&gt; d
#&lt;Delay@15c5bba: 2&gt;     ; 打印值现在带有 body 的值
</pre></div>
</div>
</div>
<span id="document-clojure.core/delay_p"></span><div class="section" id="delay">
<h3>delay?<a class="headerlink" href="#delay" title="永久链接至标题">¶</a></h3>
<p><strong>(delay? x)</strong></p>
<p>如果 <code class="docutils literal"><span class="pre">x</span></code> 是用 <code class="docutils literal"><span class="pre">delay</span></code> 创建的一个 <code class="docutils literal"><span class="pre">Delay</span></code> 对象，那么返回 <code class="docutils literal"><span class="pre">true</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L691">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">delay?</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">false</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">delay?</span> <span class="p">(</span><span class="nf">delay</span><span class="p">))</span>
<span class="nv">true</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/deref"></span><div class="section" id="deref">
<span id="id1"></span><h3>deref<a class="headerlink" href="#deref" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(deref ref)</strong></div>
<div class="line"><strong>(deref ref timeout-ms timeout-val)</strong></div>
</div>
<p><code class="docutils literal"><span class="pre">deref</span></code> 等同于这些读入器宏(reader macro)： <code class="docutils literal"><span class="pre">&#64;ref</span></code> / <code class="docutils literal"><span class="pre">&#64;agent</span></code> / <code class="docutils literal"><span class="pre">&#64;var</span></code> / <code class="docutils literal"><span class="pre">&#64;atom</span></code> / <code class="docutils literal"><span class="pre">&#64;delay</span></code> / <code class="docutils literal"><span class="pre">&#64;future</span></code> / <code class="docutils literal"><span class="pre">&#64;promise</span></code> 。</p>
<p>在事务中调用 <code class="docutils literal"><span class="pre">deref</span></code> 时，返回 <code class="docutils literal"><span class="pre">ref</span></code> 的事务值(in-transaction-value)；在非事务情况下调用，则返回 <code class="docutils literal"><span class="pre">ref</span></code> 的最近一次提交值(most-recently-committed value).</p>
<p>应用于 <code class="docutils literal"><span class="pre">var</span></code> 、 <code class="docutils literal"><span class="pre">agent</span></code> 或 <code class="docutils literal"><span class="pre">atom</span></code> 时，返回它们的当前状态。</p>
<p>应用于 <code class="docutils literal"><span class="pre">future</span></code> 时，如果计算尚未完成，那么阻塞。</p>
<p>应用于 <code class="docutils literal"><span class="pre">promise</span></code> 时，如果该 <code class="docutils literal"><span class="pre">promise</span></code> 还没用 <code class="docutils literal"><span class="pre">deliver</span></code> 设置过值，那么阻塞。</p>
<p>带 <code class="docutils literal"><span class="pre">timeout</span></code> 参数的变种(variant)用于处理 <code class="docutils literal"><span class="pre">future</span></code> 和 <code class="docutils literal"><span class="pre">promise</span></code> 这种可能会阻塞的引用(reference)：当阻塞时长超过 <code class="docutils literal"><span class="pre">timeout</span></code> 毫秒，而引用还未有值可用时，返回 <code class="docutils literal"><span class="pre">timeout-val</span></code> 作为值。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L2067">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 普通的 deref</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">d</span> <span class="p">(</span><span class="nf">delay</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/d</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">d</span><span class="p">)</span>
<span class="mi">2</span>

<span class="nv">user=&gt;</span> <span class="o">@</span><span class="nv">d</span>
<span class="mi">2</span>

<span class="c1">; 带超时的 deref</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">p</span> <span class="p">(</span><span class="nf">promise</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/p</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">deref </span><span class="nv">p</span> <span class="mi">5000</span> <span class="nv">nil</span><span class="p">)</span>   <span class="c1">; 5 秒内没有可用值，就返回 nil</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/dissoc"></span><div class="section" id="dissoc">
<h3>dissoc<a class="headerlink" href="#dissoc" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(dissoc map)</strong></div>
<div class="line"><strong>(dissoc map key)</strong></div>
<div class="line"><strong>(dissoc map key &amp; keys)</strong></div>
</div>
<p>dissoc 表示 dissociate 的意思。</p>
<p><code class="docutils literal"><span class="pre">dissoc</span></code> 接受一个 Map ，以及任意个数的 <code class="docutils literal"><span class="pre">key</span></code> ，
返回一个和传入 Map 类型相同的新 Map ，
这个新 Map 不包含所有给定 <code class="docutils literal"><span class="pre">key</span></code> 的映射。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dissoc </span><span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span><span class="p">})</span>                               <span class="c1">; 没有传入 key</span>
<span class="p">{</span><span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span>, <span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dissoc </span><span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span><span class="p">}</span> <span class="ss">:python</span><span class="p">)</span>                       <span class="c1">; 传入单个 key</span>
<span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dissoc </span><span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span><span class="p">}</span> <span class="ss">:ruby</span><span class="p">)</span>                         <span class="c1">; 传入一个不存在于 Map 的 key</span>
<span class="p">{</span><span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span>, <span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dissoc </span><span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span> <span class="ss">:ruby</span> <span class="s">&quot;Matz&quot;</span><span class="p">}</span> <span class="ss">:python</span> <span class="ss">:ruby</span><span class="p">)</span>    <span class="c1">; 传入多个 key</span>
<span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/distinct"></span><div class="section" id="distinct">
<h3>distinct<a class="headerlink" href="#distinct" title="永久链接至标题">¶</a></h3>
<p><strong>(distinct coll)</strong></p>
<p>给定一个 <code class="docutils literal"><span class="pre">coll</span></code> ，返回一个无重复元素的惰性序列。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 有重复元素的向量</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">distinct </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>


<span class="c1">; 无重复元素的向量</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">distinct </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/doall"></span><div class="section" id="doall">
<h3>doall<a class="headerlink" href="#doall" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(doall coll)</strong></div>
<div class="line"><strong>(doall n coll)</strong></div>
</div>
<p>对于那些带副作用的函数所生成的惰性序列来说，只有当列表的某个元素被求值时，该元素的副作用才会被显现出来。</p>
<p><code class="docutils literal"><span class="pre">doall</span></code> 使用 <code class="docutils literal"><span class="pre">next</span></code> 函数遍历整个序列，从而迫使惰性序列的副作用产生。</p>
<p>这个函数返回序列的首个元素作为结果，因此它需要在内存中保存整个序列。</p>
<p>自 Clojure 1.0 以来可用。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">one-to-three</span> <span class="p">(</span><span class="nb">range </span><span class="mi">3</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/one-to-three</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">doall </span><span class="nv">one-to-three</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="nv">one-to-three</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/dorun"></span><div class="section" id="dorun">
<h3>dorun<a class="headerlink" href="#dorun" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(dorun coll)</strong></div>
<div class="line"><strong>(dorun n coll)</strong></div>
</div>
<p>对于那些带副作用的函数所生成的惰性序列来说，只有当列表的某个元素被求值时，该元素的副作用才会被显现出来。</p>
<p><code class="docutils literal"><span class="pre">dorun</span></code> 使用 <code class="docutils literal"><span class="pre">next</span></code> 函数遍历整个序列，从而迫使惰性列表的副作用产生。</p>
<p>这个函数返回 <code class="docutils literal"><span class="pre">nil</span></code> ，而不是序列的首个元素。</p>
<p>自 Clojure 1.0 版本以来可用。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">infinity-hi</span> <span class="p">(</span><span class="nf">repeatedly</span> <span class="o">#</span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;hi&quot;</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/infinity-hi</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dorun </span><span class="mi">5</span> <span class="nv">infinity-hi</span><span class="p">)</span>
<span class="nv">hi</span>
<span class="nv">hi</span>
<span class="nv">hi</span>
<span class="nv">hi</span>
<span class="nv">hi</span>
<span class="nv">hi</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">one-to-ten</span> <span class="p">(</span><span class="nb">map println </span><span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/one-to-ten</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">dorun </span><span class="nv">one-to-ten</span><span class="p">)</span>
<span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">6</span>
<span class="mi">7</span>
<span class="mi">8</span>
<span class="mi">9</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/doseq"></span><div class="section" id="doseq">
<h3>doseq<a class="headerlink" href="#doseq" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(doseq seq-exprs &amp; body)</strong></div>
</div>
<p>使用和 <code class="docutils literal"><span class="pre">for</span></code> 宏一样的绑定和过滤器，反复执行 <code class="docutils literal"><span class="pre">body</span></code> （通常是为了产生副作用）。</p>
<p>返回 <code class="docutils literal"><span class="pre">nil</span></code> 而不是序列的首元素作为函数结果。</p>
<p>自 Clojure 1.0 版本以来可用。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)]</span> <span class="p">(</span><span class="nb">prn </span><span class="nv">i</span><span class="p">))</span>
<span class="mi">0</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="mi">6</span>
<span class="mi">7</span>
<span class="mi">8</span>
<span class="mi">9</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/empty"></span><div class="section" id="empty">
<h3>empty?<a class="headerlink" href="#empty" title="永久链接至标题">¶</a></h3>
<p><strong>(empty? coll)</strong></p>
<p>如果 <code class="docutils literal"><span class="pre">coll</span></code> 中不包含任何元素，那么返回 <code class="docutils literal"><span class="pre">true</span></code> ，
效果等同于执行 <code class="docutils literal"><span class="pre">(not</span> <span class="pre">(seq</span> <span class="pre">coll))</span></code> 。</p>
<p>请使用惯用法 <code class="docutils literal"><span class="pre">(seq</span> <span class="pre">x)</span></code> 代替 <code class="docutils literal"><span class="pre">(not</span> <span class="pre">(empty?</span> <span class="pre">x))</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">empty?</span> <span class="o">&#39;</span><span class="p">())</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">empty?</span> <span class="nv">nil</span><span class="p">)</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">empty?</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="nv">false</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/even"></span><div class="section" id="even">
<h3>even?<a class="headerlink" href="#even" title="永久链接至标题">¶</a></h3>
<p><strong>(even? n)</strong></p>
<p>当n是偶数时返回true，如果n不是一个整数则抛出异常</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="nf">even?</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">true</span>
<span class="p">(</span><span class="nf">even?</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">false</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/first"></span><div class="section" id="first">
<h3>first<a class="headerlink" href="#first" title="永久链接至标题">¶</a></h3>
<p><strong>(first coll)</strong></p>
<p>返回 <code class="docutils literal"><span class="pre">coll</span></code>  中的第一个元素。</p>
<p>传入的 <code class="docutils literal"><span class="pre">coll</span></code> 会被 <code class="docutils literal"><span class="pre">seq</span></code> 函数处理。</p>
<p>如果 <code class="docutils literal"><span class="pre">coll</span></code> 为 <code class="docutils literal"><span class="pre">nil</span></code> ，返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="nv">nil</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="mi">1</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">1</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">first </span><span class="p">{</span><span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span> <span class="ss">:ruby</span> <span class="s">&quot;Matz&quot;</span><span class="p">})</span>
<span class="p">[</span><span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/file-seq"></span><div class="section" id="file-seq">
<h3>file-seq<a class="headerlink" href="#file-seq" title="永久链接至标题">¶</a></h3>
<p><strong>(file-seq dir)</strong></p>
<p>返回一个惰性序列，
序列包含给定目录 <code class="docutils literal"><span class="pre">dir</span></code> 的整个目录树
（包括目录中的文件和目录中的文件夹及文件夹里的文件）。</p>
<p><code class="docutils literal"><span class="pre">dir</span></code> 必须是一个 <code class="docutils literal"><span class="pre">java.io.File</span></code> 对象。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 引入 file 函数，它可以根据路径名创建一个 File 对象</span>
<span class="c1">; 我们打开 /tmp 文件夹，并打印它的目录树</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">file</span><span class="p">]])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">tmp-folder</span> <span class="p">(</span><span class="nf">file</span> <span class="s">&quot;/tmp&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/tmp-folder</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">file-seq </span><span class="nv">tmp-folder</span><span class="p">)</span>
<span class="p">(</span><span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.esd-1000&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.esd-1000/socket&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.Test-unix&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/mongodb-27017.sock&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/at-spi2&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/at-spi2/socket-1179-1131176229&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/at-spi2/socket-1268-1804289383&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/at-spi2/socket-1169-1369485920&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/mongodb-28017.sock&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.X0-lock&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.org.chromium.Chromium.NUsJHg&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.org.chromium.Chromium.NUsJHg/SingletonSocket&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.org.chromium.Chromium.NUsJHg/SingletonCookie&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja/ssh&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja/gpg&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja/pkcs11&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja/control&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.ICE-unix&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.ICE-unix/1303&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/cron.qpBNVU&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-PKdhtXMmr18n&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/ssh-ElvUhBgb1303&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/ssh-ElvUhBgb1303/agent.1303&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.font-unix&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-397VI5uG1yhc&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-397VI5uG1yhc/pid&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-397VI5uG1yhc/native&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-397VI5uG1yhc/dbus-socket&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/hsperfdata_huangz&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/hsperfdata_huangz/9350&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.X11-unix&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.X11-unix/X0&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.XIM-unix&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.esd-120&gt;</span> <span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-T9RwKSB1FebW&gt;</span><span class="p">)</span>


<span class="c1">; 使用 doseq 、 sort 和 println 函数</span>
<span class="c1">; 打印一个更美观的、经过排序的目录树</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">f</span> <span class="p">(</span><span class="nb">sort </span><span class="p">(</span><span class="nb">file-seq </span><span class="nv">tmp</span><span class="p">))]</span>
         <span class="p">(</span><span class="nb">println </span><span class="nv">f</span><span class="p">))</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.ICE-unix&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.ICE-unix/1303&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.Test-unix&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.X0-lock&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.X11-unix&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.X11-unix/X0&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.XIM-unix&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.esd-1000&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.esd-1000/socket&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.esd-120&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.font-unix&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.org.chromium.Chromium.NUsJHg&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.org.chromium.Chromium.NUsJHg/SingletonCookie&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/.org.chromium.Chromium.NUsJHg/SingletonSocket&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/at-spi2&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/at-spi2/socket-1169-1369485920&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/at-spi2/socket-1179-1131176229&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/at-spi2/socket-1268-1804289383&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/cron.qpBNVU&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/hsperfdata_huangz&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/hsperfdata_huangz/9350&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja/control&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja/gpg&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja/pkcs11&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/keyring-NwNaja/ssh&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/mongodb-27017.sock&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/mongodb-28017.sock&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-397VI5uG1yhc&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-397VI5uG1yhc/dbus-socket&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-397VI5uG1yhc/native&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-397VI5uG1yhc/pid&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-PKdhtXMmr18n&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/pulse-T9RwKSB1FebW&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/ssh-ElvUhBgb1303&gt;</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/ssh-ElvUhBgb1303/agent.1303&gt;</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/filter"></span><div class="section" id="filter">
<h3>filter<a class="headerlink" href="#filter" title="永久链接至标题">¶</a></h3>
<p><strong>(filter pred coll)</strong></p>
<p>返回一个惰性序列，
序列中包含 <code class="docutils literal"><span class="pre">coll</span></code> 里所有 <code class="docutils literal"><span class="pre">(pred</span> <span class="pre">item)</span></code> 测试结果为 <code class="docutils literal"><span class="pre">true</span></code> 的项。</p>
<p><code class="docutils literal"><span class="pre">pred</span></code> 必须是一个无副作用的函数。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 过滤 0 - 9 中所有的奇数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">8</span><span class="p">)</span>


<span class="c1">; 过滤 0 - 9 中所有的偶数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">)</span>


<span class="c1">; 过滤 0 - 9 中所有小于 10086 的数，结果为空</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">filter </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">%</span> <span class="mi">10086</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">()</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/fn"></span><div class="section" id="fn">
<h3>fn<a class="headerlink" href="#fn" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>params =&gt; positional-params*</strong> 或者 <strong>positional-params* &amp; next-param</strong></div>
<div class="line"><strong>positional-param =&gt; binding-form</strong></div>
<div class="line"><strong>next-param =&gt; binding-form</strong></div>
<div class="line"><strong>name =&gt; symbol</strong></div>
</div>
<p>定义一个（匿名）函数。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">fn </span><span class="nv">greeting</span> <span class="p">[</span><span class="nv">name</span><span class="p">]</span>                                          <span class="c1">; 创建匿名函数</span>
           <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello, &quot;</span> <span class="nb">name </span><span class="s">&quot; .&quot;</span><span class="p">))</span>
<span class="c1">;#&lt;user$eval1$greeting__2 user$eval1$greeting__2@616fde&gt;</span>

<span class="nv">user=&gt;</span> <span class="p">((</span><span class="k">fn </span><span class="nv">greeting</span> <span class="p">[</span><span class="nv">name</span><span class="p">]</span>                                         <span class="c1">; 应用匿名函数</span>
           <span class="p">(</span><span class="nb">str </span><span class="s">&quot;hello, &quot;</span> <span class="nb">name </span><span class="s">&quot; .&quot;</span><span class="p">))</span>
        <span class="s">&quot;moto&quot;</span><span class="p">)</span>
<span class="s">&quot;hello, moto .&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">((</span><span class="k">fn </span><span class="nv">greeting</span>                                                <span class="c1">; 参数重载（arity overloading）</span>
            <span class="p">([</span><span class="nv">name</span><span class="p">]</span>
                <span class="p">(</span><span class="nf">greeting</span> <span class="s">&quot;Hello&quot;</span> <span class="nv">name</span><span class="p">))</span>
            <span class="p">([</span><span class="nv">msg</span> <span class="nv">name</span><span class="p">]</span>
                <span class="p">(</span><span class="nb">str </span><span class="nv">msg</span> <span class="s">&quot;, &quot;</span> <span class="nb">name </span><span class="s">&quot; .&quot;</span><span class="p">)))</span>
        <span class="s">&quot;moto&quot;</span><span class="p">)</span>
<span class="s">&quot;Hello, moto .&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">((</span><span class="k">fn </span><span class="nv">greeting</span>                                                <span class="c1">; 接受不定数量参数的函数</span>
            <span class="p">[</span><span class="nb">name </span><span class="o">&amp;</span> <span class="nv">others</span><span class="p">]</span>
            <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">seq </span><span class="nv">others</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello, &quot;</span> <span class="nb">name </span><span class="s">&quot; and others: &quot;</span> <span class="nv">others</span> <span class="s">&quot; .&quot;</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">str </span><span class="s">&quot;Hello, &quot;</span> <span class="nb">name </span><span class="s">&quot; .&quot;</span><span class="p">)))</span>
        <span class="s">&quot;moto&quot;</span> <span class="s">&quot;nokia&quot;</span> <span class="s">&quot;apple&quot;</span><span class="p">)</span>
<span class="s">&quot;Hello, moto and others: (\&quot;nokia\&quot; \&quot;apple\&quot;) .&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/future"></span><div class="section" id="future">
<span id="id1"></span><h3>future<a class="headerlink" href="#future" title="永久链接至标题">¶</a></h3>
<p><strong>(future &amp; body)</strong></p>
<p>参数 <code class="docutils literal"><span class="pre">body</span></code> 接受一系列表达式，并返回一个 <code class="docutils literal"><span class="pre">future</span></code> 对象，使用 <code class="docutils literal"><span class="pre">deref</span></code> 或者 <code class="docutils literal"><span class="pre">&#64;</span></code> 可以对这个对象进行强迫求值。</p>
<p><code class="docutils literal"><span class="pre">future</span></code> 对象会在另一个线程里对 <code class="docutils literal"><span class="pre">body</span></code> 进行求值，并将求值结果保存到缓存中，之后对这个 <code class="docutils literal"><span class="pre">future</span></code> 对象的所有强迫求值都会返回这个缓存值。</p>
<p>如果强迫求值时 <code class="docutils literal"><span class="pre">body</span></code> 的计算还没完成，那么调用者将被阻塞，直到计算完成，或者 <code class="docutils literal"><span class="pre">deref</span></code> 设置的过期时间到达为止。</p>
<div class="highlight-clojure"><div class="highlight"><pre>; 普通的 future 调用

user=&gt; (def f (future (+ 1 1)))
#&#39;user/f

user=&gt; f
#&lt;core$future_call$reify__6110@fae040: 2&gt;

user=&gt; @f
2

; 一个停滞 5 秒的 future 调用

user=&gt; @(future (println &quot;start sleep&quot;) (Thread/sleep 5000) 10086)
start sleep
10086

; 一个带 timeout 的 deref 调用的例子，防止阻塞时间过长

user=&gt; (deref (future (Thread/sleep 10000000000000000))
              1000
              &quot;reach block timeout&quot;) ; 停滞 1 秒之后返回字符串值
&quot;reach block timeout&quot;
</pre></div>
</div>
</div>
<span id="document-clojure.core/get"></span><div class="section" id="get">
<h3>get<a class="headerlink" href="#get" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(get map key)</strong></div>
<div class="line"><strong>(get map key not-found)</strong></div>
</div>
<p>返回 <code class="docutils literal"><span class="pre">map</span></code> 中 <code class="docutils literal"><span class="pre">key</span></code> 所映射的值。</p>
<p>如果该 <code class="docutils literal"><span class="pre">key</span></code> 不存在，且给定了 <code class="docutils literal"><span class="pre">not-found</span></code> ，那么返回 <code class="docutils literal"><span class="pre">not-found</span></code> ，否则，返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L1388">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">clojure</span> <span class="p">{</span><span class="ss">:author</span> <span class="s">&quot;Rich Hickey&quot;</span><span class="p">})</span>
<span class="o">#</span><span class="ss">&#39;user/clojure</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">get </span><span class="nv">clojure</span> <span class="ss">:author</span><span class="p">)</span>
<span class="s">&quot;Rich Hickey&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">get </span><span class="nv">clojure</span> <span class="ss">:version</span><span class="p">)</span>       <span class="c1">; 无 not-found 参数</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">get </span><span class="nv">clojure</span> <span class="ss">:version</span> <span class="mf">1.4</span><span class="p">)</span>   <span class="c1">; 有 not-found 参数</span>
<span class="mf">1.4</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/if-let"></span><div class="section" id="if-let">
<h3>if-let<a class="headerlink" href="#if-let" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(if-let bindings then)</strong></div>
<div class="line"><strong>(if-let bindings then else &amp; oldform)</strong></div>
</div>
<div class="line-block">
<div class="line"><strong>bindings =&gt; binding-form test</strong></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">test</span></code> 为真，那么结合 <code class="docutils literal"><span class="pre">binding-form</span></code> 绑定，对 <code class="docutils literal"><span class="pre">then</span></code> 部分进行求值。</p>
<p>如果 <code class="docutils literal"><span class="pre">test</span></code> 为假，那么对 <code class="docutils literal"><span class="pre">else</span></code> 部分进行求值。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">sum-all-even-number</span> <span class="p">[</span><span class="nv">all-number</span><span class="p">]</span>
           <span class="p">(</span><span class="nb">if-let </span><span class="p">[</span><span class="nv">all-even-number</span> <span class="p">(</span><span class="nb">filter </span><span class="nv">even?</span> <span class="nv">all-number</span><span class="p">)]</span>
               <span class="p">(</span><span class="nb">reduce + </span><span class="nv">all-even-number</span><span class="p">)</span>
               <span class="mi">0</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/sum-all-even-number</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">sum-all-even-number</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">])</span>
<span class="mi">20</span>  <span class="c1">; 2 + 4 + 6 + 8</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">sum-all-even-number</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">])</span>
<span class="mi">0</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/if-not"></span><div class="section" id="if-not">
<h3>if-not<a class="headerlink" href="#if-not" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(if-not test then)</strong></div>
<div class="line"><strong>(if-not test then else)</strong></div>
</div>
<p>对 <code class="docutils literal"><span class="pre">test</span></code> 部分进行求值，如果结果为 <code class="docutils literal"><span class="pre">false</span></code> ，那么对 <code class="docutils literal"><span class="pre">then</span></code> 部分求值。</p>
<p>另一方面，如果 <code class="docutils literal"><span class="pre">test</span></code> 部分的求值结果为 <code class="docutils literal"><span class="pre">true</span></code> ，且 <code class="docutils literal"><span class="pre">else</span></code> 部分不为空，那么求值 <code class="docutils literal"><span class="pre">else</span></code> 部分；否则返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">if-not </span><span class="nv">false</span> <span class="ss">:then-part</span> <span class="ss">:else-part</span><span class="p">)</span>
<span class="ss">:then-part</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">if-not </span><span class="nv">true</span> <span class="ss">:then-part</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">if-not </span><span class="nv">true</span> <span class="ss">:then-part</span> <span class="ss">:else-part</span><span class="p">)</span>
<span class="ss">:else-part</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/import"></span><div class="section" id="import">
<h3>import<a class="headerlink" href="#import" title="永久链接至标题">¶</a></h3>
<p><strong>(import &amp; import-symbols-or-lists)</strong></p>
<p><strong>import-list =&gt; (package-symbol class-name-symbols*)</strong></p>
<p>对于 <code class="docutils literal"><span class="pre">class-name-symbols</span></code> 中的每个 <code class="docutils literal"><span class="pre">name</span></code> 来说，
将名字为 <code class="docutils literal"><span class="pre">package.name</span></code> 的类添加到当前 namespace 当中。</p>
<p>可以在 <code class="docutils literal"><span class="pre">ns</span></code> 宏中通过 <code class="docutils literal"><span class="pre">:import</span></code> 来调用这个函数。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="nv">java.util.Date</span><span class="p">)</span>                      <span class="c1">; 载入单个类</span>
<span class="nv">java.util.Date</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="nf">Date.</span><span class="p">))</span>
<span class="s">&quot;Wed Jun 20 23:18:42 CST 2012&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">import </span><span class="o">&#39;</span><span class="p">(</span><span class="nf">java.util</span> <span class="nv">Date</span> <span class="nv">Calendar</span><span class="p">)</span>           <span class="c1">; 载入多个类</span>
               <span class="o">&#39;</span><span class="p">(</span><span class="nf">java.net</span> <span class="nv">URI</span> <span class="nv">ServerSocket</span><span class="p">))</span>
<span class="nv">java.net.ServerSocket</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">ns </span><span class="nv">foo.bar</span>                                  <span class="c1">; 在 ns 宏中使用</span>
           <span class="p">(</span><span class="ss">:import</span> <span class="p">(</span><span class="nf">java.util</span> <span class="nv">Date</span> <span class="nv">Calendar</span><span class="p">)</span>
                    <span class="p">(</span><span class="nf">java.net</span> <span class="nv">URI</span> <span class="nv">ServerSocket</span><span class="p">)))</span>
<span class="nv">java.net.ServerSocket</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/into"></span><div class="section" id="into">
<h3>into<a class="headerlink" href="#into" title="永久链接至标题">¶</a></h3>
<p><strong>(into to from)</strong></p>
<p>将from-coll中的所有元素合并至to-coll并返回结果</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">into </span><span class="p">(</span><span class="nf">sorted-map</span><span class="p">)</span> <span class="p">[</span> <span class="p">[</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="ss">:c</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="ss">:b</span> <span class="mi">2</span><span class="p">]</span> <span class="p">]</span> <span class="p">)</span>
<span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span>, <span class="ss">:b</span> <span class="mi">2</span>, <span class="ss">:c</span> <span class="mi">3</span><span class="p">}</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">into </span><span class="p">(</span><span class="nf">sorted-map</span><span class="p">)</span> <span class="p">[</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{</span><span class="ss">:c</span> <span class="mi">3</span><span class="p">}</span> <span class="p">{</span><span class="ss">:b</span> <span class="mi">2</span><span class="p">}</span> <span class="p">]</span> <span class="p">)</span>
<span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span>, <span class="ss">:b</span> <span class="mi">2</span>, <span class="ss">:c</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/iterate"></span><div class="section" id="iterate">
<h3>iterate<a class="headerlink" href="#iterate" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(iterate f x)</strong></div>
</div>
<p>返回一个惰性序列，
序列元素的值为 <code class="docutils literal"><span class="pre">x</span></code> 、 <code class="docutils literal"><span class="pre">(f</span> <span class="pre">x)</span></code> 、 <code class="docutils literal"><span class="pre">(f</span> <span class="pre">(f</span> <span class="pre">x))</span></code> 、 <code class="docutils literal"><span class="pre">(f</span> <span class="pre">(f</span> <span class="pre">(f</span> <span class="pre">x)))</span></code> ，
诸如此类。</p>
<p>函数 <code class="docutils literal"><span class="pre">f</span></code> 必须是无副作用的。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 生成一个计算所有正整数的惰性序列</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">z</span> <span class="p">(</span><span class="nb">iterate inc </span><span class="mi">1</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/z</span>


<span class="c1">; 取出第一个和第二个正整数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">z</span> <span class="mi">0</span><span class="p">)</span>
<span class="mi">1</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">z</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">2</span>


<span class="c1">; 取出前十个正整数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="nv">z</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/keep-indexed"></span><div class="section" id="keep-indexed">
<h3>keep-indexed<a class="headerlink" href="#keep-indexed" title="永久链接至标题">¶</a></h3>
<p><strong>(keep-indexed f coll)</strong></p>
<p>对于 <code class="docutils literal"><span class="pre">coll</span></code> 中的每个项 <code class="docutils literal"><span class="pre">item</span></code> ，
以及 <code class="docutils literal"><span class="pre">item</span></code> 对应的索引下标 <code class="docutils literal"><span class="pre">index</span></code> ，
<code class="docutils literal"><span class="pre">(keep-indexed</span> <span class="pre">f</span> <span class="pre">coll)</span></code> 返回一个惰性序列，
序列中包含 <code class="docutils literal"><span class="pre">(f</span> <span class="pre">index</span> <span class="pre">item)</span></code> 除 <code class="docutils literal"><span class="pre">nil</span></code> 之外的所有计算结果。</p>
<p>因为带副作用的函数会返回与计算结果无关的虚假值，
因此，为了确保虚假值不会混进 <code class="docutils literal"><span class="pre">keep-indexed</span></code> 所生成的惰性序列中，
<code class="docutils literal"><span class="pre">f</span></code> 必须是一个无副作用的函数。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 返回 0 - 9 内所有排序位置(index)为偶数的数字</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">keep-indexed</span> <span class="o">#</span><span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">even?</span> <span class="nv">%1</span><span class="p">)</span> <span class="nv">%2</span> <span class="nv">nil</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/keep"></span><div class="section" id="keep">
<h3>keep<a class="headerlink" href="#keep" title="永久链接至标题">¶</a></h3>
<p><strong>(keep f coll)</strong></p>
<p>对于 <code class="docutils literal"><span class="pre">coll</span></code> 中的每个项 <code class="docutils literal"><span class="pre">item</span></code> ，
<code class="docutils literal"><span class="pre">(keep</span> <span class="pre">f</span> <span class="pre">coll)</span></code> 返回一个惰性序列，
序列包含 <code class="docutils literal"><span class="pre">(f</span> <span class="pre">item)</span></code> 除 <code class="docutils literal"><span class="pre">nil</span></code> 之外的所有计算结果。</p>
<p>因为带副作用的函数会返回与计算结果无关的虚假值，
因此，为了确保虚假值不会混进 <code class="docutils literal"><span class="pre">keep</span></code> 所生成的惰性序列中，
<code class="docutils literal"><span class="pre">f</span></code> 必须是一个无副作用的函数。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">keep</span> <span class="nb">inc </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>

<span class="c1">; 将空的 collection 传给 seq 函数会返回 nil</span>
<span class="c1">; 可以根据这个性质来测试 keep</span>
<span class="c1">; 看它是否真的会省略等于 nil 的值</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq </span><span class="p">[])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">keep</span> <span class="nb">seq </span><span class="p">(</span><span class="nb">list </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[]</span> <span class="p">[</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]))</span>
<span class="p">((</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">))</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/key"></span><div class="section" id="key">
<h3>key<a class="headerlink" href="#key" title="永久链接至标题">¶</a></h3>
<p><strong>(key e)</strong></p>
<p>返回map的键集合</p>
<dl class="docutils">
<dt>::</dt>
<dd>(map key {:a 1,:b 2})
(:a :b)</dd>
</dl>
</div>
<span id="document-clojure.core/keys"></span><div class="section" id="keys">
<h3>keys<a class="headerlink" href="#keys" title="永久链接至标题">¶</a></h3>
<p><strong>(keys map)</strong></p>
<p>返回一个序列，序列里包含给定 <code class="docutils literal"><span class="pre">map</span></code> 的所有键(key)。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 空 Map</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">keys </span><span class="p">{})</span>
<span class="nv">nil</span>

<span class="c1">; 非空 Map</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">keys </span><span class="p">{</span><span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span> <span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:ruby</span> <span class="s">&quot;Matz&quot;</span><span class="p">})</span>
<span class="p">(</span><span class="ss">:python</span> <span class="ss">:ruby</span> <span class="ss">:clojure</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/letfn"></span><div class="section" id="letfn">
<h3>letfn<a class="headerlink" href="#letfn" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(letfn fnspecs &amp; body)</strong></div>
</div>
<div class="line-block">
<div class="line"><strong>fnspecs ==&gt; (fname [params*] exprs)</strong> 或者 <strong>(fname ([params*] exprs)+)</strong></div>
</div>
<p>使用一个函数体 <code class="docutils literal"><span class="pre">body</span></code> ，以及一个带有函数规格(specs)的向量 <code class="docutils literal"><span class="pre">fnspecs</span></code> ，
将向量里的名字和相应的函数进行绑定。</p>
<p>向量里的名字在函数定义中，还有函数体内，都是可见的。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">letfn</span> <span class="p">[(</span><span class="nf">twice</span> <span class="p">[</span><span class="nv">x</span><span class="p">]</span>
                  <span class="p">(</span><span class="nb">* </span><span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>
               <span class="p">(</span><span class="nf">six-times</span> <span class="p">[</span><span class="nv">y</span><span class="p">]</span>
                  <span class="p">(</span><span class="nb">* </span><span class="mi">3</span> <span class="p">(</span><span class="nf">twice</span> <span class="nv">y</span><span class="p">)))]</span>
           <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Twice 15 = &quot;</span> <span class="p">(</span><span class="nf">twice</span> <span class="mi">15</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">println </span><span class="s">&quot;Six times 15 = &quot;</span> <span class="p">(</span><span class="nf">six-times</span> <span class="mi">15</span><span class="p">)))</span>
<span class="nv">Twice</span> <span class="mi">15</span> <span class="nb">= </span><span class="mi">30</span>
<span class="nv">Six</span> <span class="nv">times</span> <span class="mi">15</span> <span class="nb">= </span><span class="mi">90</span>
<span class="nv">nil</span>

<span class="c1">;; 名字 twice 和 six-times 在离开 letfn 之后不可用</span>

<span class="c1">;user=&gt; (twice 15)</span>
<span class="c1">;CompilerException java.lang.RuntimeException: Unable to resolve symbol: twice in this context, compiling:(NO_SOURCE_PATH:7)</span>

<span class="c1">;user=&gt; (six-times 15)</span>
<span class="c1">;CompilerException java.lang.RuntimeException: Unable to resolve symbol: six-times in this context, compiling:(NO_SOURCE_PATH:8)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/line-seq"></span><div class="section" id="line-seq">
<h3>line-seq<a class="headerlink" href="#line-seq" title="永久链接至标题">¶</a></h3>
<p><strong>(line-seq rdr)</strong></p>
<p>返回一个惰性序列，
序列里包含从文件 <code class="docutils literal"><span class="pre">rdr</span></code> 中读出的所有字符串行。</p>
<p><code class="docutils literal"><span class="pre">rdr</span></code> 必须是一个 <code class="docutils literal"><span class="pre">java.io.BufferedReader</span></code> 对象。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 引入 reader 函数，它可以创建一个 java.io.BufferedReader 对象</span>
<span class="c1">; 读出 animal.txt 文件中的所有内容，之后再将文件联接关闭</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:only</span> <span class="p">[</span><span class="nv">reader</span><span class="p">]])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">animal</span> <span class="p">(</span><span class="nf">reader</span> <span class="s">&quot;animal.txt&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/animal</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">line-seq </span><span class="nv">animal</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;dog&quot;</span> <span class="s">&quot;cat&quot;</span> <span class="s">&quot;monkey&quot;</span> <span class="s">&quot;lion&quot;</span> <span class="s">&quot;tiger&quot;</span> <span class="s">&quot;dolphin&quot;</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">.close</span> <span class="nv">animal</span><span class="p">)</span>
<span class="nv">nil</span>


<span class="c1">; 用 with-open 来自动处理文件的打开和关闭</span>
<span class="c1">; 并用更美观的方式打印 animal.txt 文件的内容</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">animal</span> <span class="p">(</span><span class="nf">reader</span> <span class="s">&quot;animal.txt&quot;</span><span class="p">)]</span>
         <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">all-animal</span> <span class="p">(</span><span class="nb">line-seq </span><span class="nv">animal</span><span class="p">)]</span>
            <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">a</span> <span class="nv">all-animal</span><span class="p">]</span>
                <span class="p">(</span><span class="nb">println </span><span class="nv">a</span><span class="p">))))</span>
<span class="nv">dog</span>
<span class="nv">cat</span>
<span class="nv">monkey</span>
<span class="nv">lion</span>
<span class="nv">tiger</span>
<span class="nv">dolphin</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/map-indexed"></span><div class="section" id="map-indexed">
<h3>map-indexed<a class="headerlink" href="#map-indexed" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(map-indexed f coll)</strong></div>
</div>
<p>返回一个惰性序列，
序列里的第一个元素是将 <code class="docutils literal"><span class="pre">0</span></code> 和 <code class="docutils literal"><span class="pre">coll</span></code> 的第一个元素应用到 <code class="docutils literal"><span class="pre">f</span></code> 所得出的值，
序列里的第二个元素是将 <code class="docutils literal"><span class="pre">1</span></code> 和 <code class="docutils literal"><span class="pre">coll</span></code> 的第二个元素应用到 <code class="docutils literal"><span class="pre">f</span></code> 所得出的值。。。
以此类推，直到 <code class="docutils literal"><span class="pre">coll</span></code> 被处理完为止。</p>
<p>函数 <code class="docutils literal"><span class="pre">f</span></code> 应该接受两个参数：一个索引值，一个是 <code class="docutils literal"><span class="pre">coll</span></code> 的元素值。</p>
<p><a class="reference external" href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/map-indexed">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">map-indexed</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">idx</span> <span class="nv">item</span><span class="p">]</span> <span class="p">[</span><span class="nv">idx</span> <span class="nv">item</span><span class="p">])</span> <span class="s">&quot;foobar&quot;</span><span class="p">)</span>
<span class="p">([</span><span class="mi">0</span> <span class="sc">\f</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span> <span class="sc">\o</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="sc">\o</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="sc">\b</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="sc">\a</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span> <span class="sc">\r</span><span class="p">])</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">map-indexed</span> <span class="nb">vector </span><span class="s">&quot;foobar&quot;</span><span class="p">)</span>    <span class="c1">; 另一种更简单的解法</span>
<span class="p">([</span><span class="mi">0</span> <span class="sc">\f</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span> <span class="sc">\o</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="sc">\o</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="sc">\b</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="sc">\a</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span> <span class="sc">\r</span><span class="p">])</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/map"></span><div class="section" id="map">
<h3>map<a class="headerlink" href="#map" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(map f coll)</strong></div>
<div class="line"><strong>(map f c1 c2)</strong></div>
<div class="line"><strong>(map f c1 c2 c3)</strong></div>
<div class="line"><strong>(map f c1 c2 c3 &amp; colls)</strong></div>
</div>
<p>返回一个惰性序列，
序列的第一个元素是所有给定 <code class="docutils literal"><span class="pre">collection</span></code> 的第一个元素应用于函数 <code class="docutils literal"><span class="pre">f</span></code> 所得出的返回值，
序列的第二个元素是所有给定 <code class="docutils literal"><span class="pre">collection</span></code> 的第二个元素应用于函数 <code class="docutils literal"><span class="pre">f</span></code> 所得出的返回值。。。以此类推，一直到给定 <code class="docutils literal"><span class="pre">collection</span></code> 的其中一个被处理完为止。</p>
<p>当其中一个 <code class="docutils literal"><span class="pre">collection</span></code> 被处理完之后，其他 <code class="docutils literal"><span class="pre">collection</span></code> 的剩余元素会被忽略，因此结果序列的长度由给定 <code class="docutils literal"><span class="pre">collection</span></code> 中长度最短的那个决定。</p>
<p>函数 <code class="docutils literal"><span class="pre">f</span></code> 的参数个数应该和给定 <code class="docutils literal"><span class="pre">collection</span></code> 的数量一致。</p>
<p><a class="reference external" href="http://clojure.github.com/clojure/clojure.core-api.html#clojure.core/map">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">;; 处理单个 collection</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">map inc </span><span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span><span class="p">)</span>


<span class="c1">;; 处理两个 collection</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">9</span> <span class="mi">8</span> <span class="mi">7</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="p">(</span><span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span><span class="p">)</span>


<span class="c1">;; 处理长度不同的两个 collection</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">map </span><span class="o">#</span><span class="p">(</span><span class="nb">+ </span><span class="nv">%1</span> <span class="nv">%2</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10086</span><span class="p">)</span> <span class="p">(</span><span class="nb">reverse </span><span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)))</span>
<span class="p">(</span><span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span> <span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/mapcat"></span><div class="section" id="mapcat">
<h3>mapcat<a class="headerlink" href="#mapcat" title="永久链接至标题">¶</a></h3>
<p><strong>(mapcat f &amp; colls)</strong></p>
<p>等同于调用 <code class="docutils literal"><span class="pre">(concat</span> <span class="pre">(map</span> <span class="pre">f</span> <span class="pre">colls))</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L2455">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">mapcat reverse </span><span class="p">[[</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="p">[</span><span class="mi">6</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">]</span>
                        <span class="p">[</span><span class="mi">9</span> <span class="mi">8</span> <span class="mi">7</span><span class="p">]])</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/max-key"></span><div class="section" id="max-key">
<h3>max-key<a class="headerlink" href="#max-key" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(max-key f item1)</strong></div>
<div class="line"><strong>(max-key f item1 item2)</strong></div>
<div class="line"><strong>(max-key f item1 item2 &amp; items)</strong></div>
</div>
<p>将函数 <code class="docutils literal"><span class="pre">f</span></code> 应用到所有给定元素上，其中 <code class="docutils literal"><span class="pre">(f</span> <span class="pre">item)</span></code> 值最大的那个 <code class="docutils literal"><span class="pre">item</span></code> 被返回。</p>
<p><code class="docutils literal"><span class="pre">(f</span> <span class="pre">item)</span></code> 的结果必须是数字值。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L4419">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">max-key count </span><span class="s">&quot;abc&quot;</span>
                      <span class="s">&quot;abcd&quot;</span>
                      <span class="s">&quot;a&quot;</span>
                      <span class="s">&quot;abcdefg&quot;</span>
                      <span class="s">&quot;aa&quot;</span><span class="p">)</span>
<span class="s">&quot;abcdefg&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/merge"></span><div class="section" id="merge">
<h3>merge<a class="headerlink" href="#merge" title="永久链接至标题">¶</a></h3>
<p><strong>(merge &amp; maps)</strong></p>
<p>返回一个含有剩余项的map。
如果key在多个map中存在，后面的值（从左向右的顺序）会覆盖前面的值</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">user=&gt; (merge {:a 1 :b 2 :c 3} {:b 9 :d 4})
{:d 4, :a 1, :b 9, :c 3}</p>
<p class="last">user=&gt; (merge {:a 1 :b 2 :c 3} {:b 9 :d 4} {:b 8 :d 3})
{:d 3, :c 3, :b 8, :a 1}</p>
</dd>
</dl>
</div>
<span id="document-clojure.core/min-key"></span><div class="section" id="min-key">
<h3>min-key<a class="headerlink" href="#min-key" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(min-key f item1)</strong></div>
<div class="line"><strong>(min-key f item1 item2)</strong></div>
<div class="line"><strong>(min-key f item1 item2 &amp; items)</strong></div>
</div>
<p>将函数 <code class="docutils literal"><span class="pre">f</span></code> 应用到所有给定元素上，其中 <code class="docutils literal"><span class="pre">(f</span> <span class="pre">item)</span></code> 值最小的那个 <code class="docutils literal"><span class="pre">item</span></code> 被返回。</p>
<p><code class="docutils literal"><span class="pre">(f</span> <span class="pre">item)</span></code> 的结果必须是数字值。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L4428">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">min-key count </span><span class="s">&quot;aaaaaaa&quot;</span>
                      <span class="s">&quot;bbbbbb&quot;</span>
                      <span class="s">&quot;ccccccc&quot;</span>
                      <span class="s">&quot;aa&quot;</span>
                      <span class="s">&quot;dddddddd&quot;</span><span class="p">)</span>
<span class="s">&quot;aa&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/next"></span><div class="section" id="next">
<h3>next<a class="headerlink" href="#next" title="永久链接至标题">¶</a></h3>
<p><strong>(next coll)</strong></p>
<p>返回 <code class="docutils literal"><span class="pre">coll</span></code> 除了第一个元素之外，余下的其他全部元素。</p>
<p>传入的 <code class="docutils literal"><span class="pre">coll</span></code> 会被 <code class="docutils literal"><span class="pre">seq</span></code> 函数处理。</p>
<p>如果 <code class="docutils literal"><span class="pre">coll</span></code> 除了 <code class="docutils literal"><span class="pre">(first</span> <span class="pre">coll)</span></code> 之外，
没有其他别的元素，那么返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">next </span><span class="nv">nil</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">next </span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">next </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">next </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/odd"></span><div class="section" id="odd">
<h3>odd?<a class="headerlink" href="#odd" title="永久链接至标题">¶</a></h3>
<p><strong>(odd? n)</strong></p>
<p>当n是奇数时返回true，如果n不是一个整数则抛出异常</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="nf">odd?</span> <span class="mi">1</span><span class="p">)</span>
<span class="nv">true</span>
<span class="p">(</span><span class="nf">odd?</span> <span class="mi">2</span><span class="p">)</span>
<span class="nv">false</span>
<span class="p">(</span><span class="nf">odd?</span> <span class="mi">0</span><span class="p">)</span>
<span class="nv">false</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/partial"></span><div class="section" id="partial">
<h3>partial<a class="headerlink" href="#partial" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(partial f arg1)</strong></div>
<div class="line"><strong>(partial f arg1 arg2)</strong></div>
<div class="line"><strong>(partial f arg1 arg2 arg3)</strong></div>
<div class="line"><strong>(partial f arg1 arg2 arg3 &amp; more)</strong></div>
</div>
<p><code class="docutils literal"><span class="pre">partial</span></code> 接受一个函数 <code class="docutils literal"><span class="pre">f</span></code> ，
以及少于正常 <code class="docutils literal"><span class="pre">f</span></code> 所接受参数数量的参数，
并返回一个匿名函数。</p>
<p>当这个匿名函数被调用时，
传给它的附加参数（additional args）会和之前给定的参数一起，
传给函数 <code class="docutils literal"><span class="pre">f</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">three-times</span> <span class="p">(</span><span class="nb">partial * </span><span class="mi">3</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/three-times</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">three-times</span> <span class="mi">10</span><span class="p">)</span>                     <span class="c1">; (* 3 10)</span>
<span class="mi">30</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">three-times</span> <span class="mi">20</span><span class="p">)</span>                     <span class="c1">; (* 3 20)</span>
<span class="mi">60</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">add-x-y-z</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">]</span>
           <span class="p">(</span><span class="nb">+ </span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/add-x-y-z</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">add-y-z</span> <span class="p">(</span><span class="nb">partial </span><span class="nv">add-x-y-z</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1">; x = 0</span>
<span class="o">#</span><span class="ss">&#39;user/add-y-z</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">add-z</span> <span class="p">(</span><span class="nb">partial </span><span class="nv">add-y-z</span> <span class="mi">1</span><span class="p">))</span>      <span class="c1">; y = 1</span>
<span class="o">#</span><span class="ss">&#39;user/add-z</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">add-z</span> <span class="mi">2</span><span class="p">)</span>                            <span class="c1">; z = 2</span>
<span class="mi">3</span>                                           <span class="c1">; (+ 0 1 2)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/pcalls"></span><div class="section" id="pcalls">
<h3>pcalls<a class="headerlink" href="#pcalls" title="永久链接至标题">¶</a></h3>
<p><strong>(pcalls &amp; fns)</strong></p>
<p>并行计算 <code class="docutils literal"><span class="pre">fns</span></code> 中的无参数函数，并以惰性序列的形式返回它们的值。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L6219">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 并行运行 3 个等待 3 秒的线程，共等待 3 秒</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pcalls</span>
         <span class="o">#</span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">3000</span><span class="p">)</span>
         <span class="o">#</span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">3000</span><span class="p">)</span>
         <span class="o">#</span><span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">3000</span><span class="p">))</span>
<span class="p">(</span><span class="nf">nil</span> <span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>因为 <code class="docutils literal"><span class="pre">pcalls</span></code> 和 <code class="docutils literal"><span class="pre">pvalues</span></code> 的返回值都是惰性序列，因此，如果有一个非常耗时的表达式阻塞在其他一些表达式的前面，那么就算后面的这些表达式已经计算完了，它们也不能被返回。</p>
<p>以下是这样一个实例，在序列前面的三个元素，可以立即被返回，但是，后面的三个元素只有等待 <code class="docutils literal"><span class="pre">(Thread/sleep</span> <span class="pre">3000)</span></code> 执行完毕之后，才会被返回，尽管它们早就在并发线程里被求值完了：</p>
<div class="last highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nf">pvalues</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
                        <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">3000</span><span class="p">)</span>
                        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;eval 4&quot;</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
                        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;eval 5&quot;</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span>
                        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;eval 6&quot;</span><span class="p">)</span> <span class="mi">6</span><span class="p">))</span>
            <span class="p">]</span>
           <span class="p">(</span><span class="nb">println </span><span class="nv">i</span><span class="p">)</span>
       <span class="p">)</span>
<span class="p">(</span><span class="mi">1</span>
<span class="mi">2</span>
<span class="nv">nil</span> <span class="nb">eval </span><span class="mi">5</span>  <span class="c1">; 从 println 的输出可以看到</span>
<span class="nb">eval </span><span class="mi">4</span>      <span class="c1">; 4 、 5 、 6 三个数已经被计算出来了，但还没办法返回</span>
<span class="mi">3</span>
<span class="nv">nil</span> <span class="nb">eval </span><span class="mi">6</span>
<span class="nv">nil</span>         <span class="c1">; sleep 执行，停滞 3 秒</span>
<span class="nv">nil</span> <span class="mi">4</span>
<span class="nv">nil</span> <span class="mi">5</span>
<span class="nv">nil</span> <span class="mi">6</span>
<span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-clojure.core/pmap"></span><div class="section" id="pmap">
<h3>pmap<a class="headerlink" href="#pmap" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(pmap f coll)</strong></div>
<div class="line"><strong>(pmap f coll &amp; colls)</strong></div>
</div>
<p><code class="docutils literal"><span class="pre">pmap</span></code> 类似于 <code class="docutils literal"><span class="pre">map</span></code> ，唯一的不同是， <code class="docutils literal"><span class="pre">pmap</span></code> 对函数 <code class="docutils literal"><span class="pre">f</span></code> 的应用是并行的。</p>
<p><code class="docutils literal"><span class="pre">pmap</span></code> 的返回值是半惰性的(semi-lazy)：
并行计算总是发生在消耗(consumption)之前，
不过，计算结果只有在被需要时，才会被 realize 。</p>
<p>只有当 <code class="docutils literal"><span class="pre">f</span></code> 为计算密集型函数，
而且并行获得的性能提升足以抵消并行所需的协调消耗时，
才应该使用 <code class="docutils literal"><span class="pre">pmap</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L6194">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 串行运行， 4 个元素，每个等待 3 秒，共等待 12 秒</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">time</span>
         <span class="p">(</span><span class="nf">dorun</span>
           <span class="p">(</span><span class="nb">map </span><span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">3000</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">range </span><span class="mi">4</span><span class="p">))))</span>
<span class="s">&quot;Elapsed time: 12000.767484 msecs&quot;</span>
<span class="nv">nil</span>

<span class="c1">; 并行运行， 4 个元素，每个等待 3 秒，共等待 3 秒</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">time</span>
         <span class="p">(</span><span class="nf">dorun</span>
           <span class="p">(</span><span class="nf">pmap</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">x</span><span class="p">]</span> <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">3000</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">range </span><span class="mi">4</span><span class="p">))))</span>
<span class="s">&quot;Elapsed time: 3002.602211 msecs&quot;</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/promise"></span><div class="section" id="promise">
<span id="id1"></span><h3>promise<a class="headerlink" href="#promise" title="永久链接至标题">¶</a></h3>
<p><strong>(promise)</strong></p>
<p><em>试验版本，将来可能会出现改动。</em></p>
<p>返回一个 <code class="docutils literal"><span class="pre">promise</span></code> 对象，可以使用 <code class="docutils literal"><span class="pre">deref</span></code> 或者 <code class="docutils literal"><span class="pre">&#64;</span></code> 读取它的值，也可以使用 <code class="docutils literal"><span class="pre">deliver</span></code> 对它进行只能设置一次的赋值。</p>
<p>如果 <code class="docutils literal"><span class="pre">promise</span></code> 对象在使用 <code class="docutils literal"><span class="pre">deliver</span></code> 设置值之前，就被 <code class="docutils literal"><span class="pre">deref</span></code> 或者 <code class="docutils literal"><span class="pre">&#64;</span></code> 读取，那么调用者将被阻塞，直到 <code class="docutils literal"><span class="pre">promise</span></code> 对象有值，或者 <code class="docutils literal"><span class="pre">deref</span></code> 设置的超时时间到期为止。</p>
<p>被 <code class="docutils literal"><span class="pre">deliver</span></code> 设置值之后，对 <code class="docutils literal"><span class="pre">promise</span></code> 的每次 <code class="docutils literal"><span class="pre">deref</span></code> 或者 <code class="docutils literal"><span class="pre">&#64;</span></code> 都会不阻塞地返回 <code class="docutils literal"><span class="pre">deliver</span></code> 所设置的值。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L6278">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre>user=&gt; (def p (promise))
#&#39;user/p

user=&gt; p
#&lt;core$promise$reify__6153@bfb588: :pending&gt;

; 对未有值的 promise 进行 deref
; 为了避免陷入无限阻塞，设置 5 秒的超时时间

user=&gt; (deref p 5000 &quot;reach timeout&quot;)
&quot;reach timeout&quot;

; 为 promise 设置值

user=&gt; (deliver p 10086)
#&lt;core$promise$reify__6153@bfb588: 10086&gt;

user=&gt; @p
10086

user=&gt; p
#&lt;core$promise$reify__6153@bfb588: 10086&gt;

; 试试重复 deliver ？

user=&gt; (deliver p 123123)
nil

user=&gt; @p
10086
</pre></div>
</div>
</div>
<span id="document-clojure.core/pvalues"></span><div class="section" id="pvalues">
<h3>pvalues<a class="headerlink" href="#pvalues" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(pvalues &amp; exprs)</strong></div>
</div>
<p>并行计算 <code class="docutils literal"><span class="pre">exprs</span></code> 中的表达式，并以惰性序列的形式返回它们的值。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L6226">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pvalues</span>
         <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">3000</span><span class="p">)</span>
         <span class="mi">10086</span>
         <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">3000</span><span class="p">)</span>
         <span class="s">&quot;hello moto&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">nil</span> <span class="mi">10086</span> <span class="nv">nil</span> <span class="s">&quot;hello moto&quot;</span><span class="p">)</span>    <span class="c1">; 返回完整的计算结果需要 3 秒时间</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>因为 <code class="docutils literal"><span class="pre">pcalls</span></code> 和 <code class="docutils literal"><span class="pre">pvalues</span></code> 的返回值都是惰性序列，因此，如果有一个非常耗时的表达式阻塞在其他一些表达式的前面，那么就算后面的这些表达式已经计算完了，它们也不能被返回。</p>
<p>以下是这样一个实例，在序列前面的三个元素，可以立即被返回，但是，后面的三个元素只有等待 <code class="docutils literal"><span class="pre">(Thread/sleep</span> <span class="pre">3000)</span></code> 执行完毕之后，才会被返回，尽管它们早就在并发线程里被求值完了：</p>
<div class="last highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">i</span> <span class="p">(</span><span class="nf">pvalues</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
                        <span class="p">(</span><span class="nf">Thread/sleep</span> <span class="mi">3000</span><span class="p">)</span>
                        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;eval 4&quot;</span><span class="p">)</span> <span class="mi">4</span><span class="p">)</span>
                        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;eval 5&quot;</span><span class="p">)</span> <span class="mi">5</span><span class="p">)</span>
                        <span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nb">println </span><span class="s">&quot;eval 6&quot;</span><span class="p">)</span> <span class="mi">6</span><span class="p">))</span>
            <span class="p">]</span>
           <span class="p">(</span><span class="nb">println </span><span class="nv">i</span><span class="p">)</span>
       <span class="p">)</span>
<span class="p">(</span><span class="mi">1</span>
<span class="mi">2</span>
<span class="nv">nil</span> <span class="nb">eval </span><span class="mi">5</span>  <span class="c1">; 从 println 的输出可以看到</span>
<span class="nb">eval </span><span class="mi">4</span>      <span class="c1">; 4 、 5 、 6 三个数已经被计算出来了，但还没办法返回</span>
<span class="mi">3</span>
<span class="nv">nil</span> <span class="nb">eval </span><span class="mi">6</span>
<span class="nv">nil</span>         <span class="c1">; sleep 执行，停滞 3 秒</span>
<span class="nv">nil</span> <span class="mi">4</span>
<span class="nv">nil</span> <span class="mi">5</span>
<span class="nv">nil</span> <span class="mi">6</span>
<span class="nv">nil</span> <span class="nv">nil</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<span id="document-clojure.core/range"></span><div class="section" id="range">
<h3>range<a class="headerlink" href="#range" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(range)</strong></div>
<div class="line"><strong>(range end)</strong></div>
<div class="line"><strong>(range start end)</strong></div>
<div class="line"><strong>(range start end step)</strong></div>
</div>
<p>返回一个惰性序列，
序列里包含从大于等于 <code class="docutils literal"><span class="pre">start</span></code> 到小于 <code class="docutils literal"><span class="pre">end</span></code>
区间内的所有数字(<code class="docutils literal"><span class="pre">start</span> <span class="pre">&lt;=</span> <span class="pre">numbers</span> <span class="pre">&lt;</span> <span class="pre">end</span></code>)，
数字的步进以 <code class="docutils literal"><span class="pre">step</span></code> 指定。</p>
<p>默认情况下， <code class="docutils literal"><span class="pre">start</span></code> 为 <code class="docutils literal"><span class="pre">0</span></code> ， <code class="docutils literal"><span class="pre">step</span></code> 为 <code class="docutils literal"><span class="pre">1</span></code> ，而 <code class="docutils literal"><span class="pre">end</span></code> 则为无限。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 不指定任何参数，返回一个包含所有非负整数的惰性序列</span>
<span class="c1">; 0, 1, 2, 3 ...</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">3</span> <span class="p">(</span><span class="nf">range</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="p">(</span><span class="nf">range</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>


<span class="c1">; 只指定 end</span>
<span class="c1">; 返回大于等于 0 到小于 end 之内的所有整数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>


<span class="c1">; 指定 start 和 end</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">0</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)</span>


<span class="c1">; 指定 start 、 end 和 step</span>
<span class="c1">; 第一个惰性序列计算 2 到 20 内的所有偶数</span>
<span class="c1">; 第二个惰性序列计算 1 到 20 内的所有奇数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">2</span> <span class="mi">20</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">8</span> <span class="mi">10</span> <span class="mi">12</span> <span class="mi">14</span> <span class="mi">16</span> <span class="mi">18</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="mi">20</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">15</span> <span class="mi">17</span> <span class="mi">19</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/re-seq"></span><div class="section" id="re-seq">
<h3>re-seq<a class="headerlink" href="#re-seq" title="永久链接至标题">¶</a></h3>
<p><strong>(re-seq re s)</strong></p>
<p>返回一个惰性序列，
序列里包含字符串 <code class="docutils literal"><span class="pre">s</span></code> 中所有匹配模式 <code class="docutils literal"><span class="pre">re</span></code> 的值，
匹配使用 <code class="docutils literal"><span class="pre">java.util.regex.Matcher.find()</span></code> 进行，
每个匹配值都经过 <code class="docutils literal"><span class="pre">re-groups</span></code> 处理。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 查找字符串中的所有数字值</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">re-seq </span><span class="o">#</span><span class="s">&quot;[0-9]+&quot;</span> <span class="s">&quot;abs123def345ghi567&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;123&quot;</span> <span class="s">&quot;345&quot;</span> <span class="s">&quot;567&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/realized"></span><div class="section" id="realized">
<h3>realized?<a class="headerlink" href="#realized" title="永久链接至标题">¶</a></h3>
<p><strong>(realized? x)</strong></p>
<p>如果给定的 <code class="docutils literal"><span class="pre">promise</span></code> 、 <code class="docutils literal"><span class="pre">delay</span></code> 、 <code class="docutils literal"><span class="pre">future</span></code> 或者 <code class="docutils literal"><span class="pre">lazy-list</span></code> 对象已经有值了，那么返回 <code class="docutils literal"><span class="pre">true</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L6604">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">d</span> <span class="p">(</span><span class="nf">delay</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/d</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">realized?</span> <span class="nv">d</span><span class="p">)</span>
<span class="nv">false</span>

<span class="nv">user=&gt;</span> <span class="o">@</span><span class="nv">d</span>
<span class="mi">2</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">realized?</span> <span class="nv">d</span><span class="p">)</span>
<span class="nv">true</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/reduce"></span><div class="section" id="reduce">
<h3>reduce<a class="headerlink" href="#reduce" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(reduce f coll)</strong></div>
<div class="line"><strong>(reduce f val coll)</strong></div>
</div>
<p><code class="docutils literal"><span class="pre">reduce</span></code> 的行为由以下情况定义：</p>
<ul>
<li><dl class="first docutils">
<dt>没有给定 <code class="docutils literal"><span class="pre">val</span></code> ：</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">coll</span></code> 为空：以无参数方式调用 <code class="docutils literal"><span class="pre">f</span></code> ，调用所得的值为返回值。</li>
<li><code class="docutils literal"><span class="pre">coll</span></code> 只有一个元素：不调用 <code class="docutils literal"><span class="pre">f</span></code> ，直接将那个元素用作返回值。</li>
<li><code class="docutils literal"><span class="pre">coll</span></code> 有多于一个元素：将 <code class="docutils literal"><span class="pre">coll</span></code> 的前两个元素应用到 <code class="docutils literal"><span class="pre">f</span></code> ，得到的结果再和 <code class="docutils literal"><span class="pre">coll</span></code> 的第三个元素一起应用到 <code class="docutils literal"><span class="pre">f</span></code> ，以此类推。</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>有给定 <code class="docutils literal"><span class="pre">val</span></code> ：</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal"><span class="pre">coll</span></code> 为空：不调用 <code class="docutils literal"><span class="pre">f</span></code> ，直接返回 <code class="docutils literal"><span class="pre">val</span></code> 。</li>
<li><code class="docutils literal"><span class="pre">coll</span></code> 不为空：将 <code class="docutils literal"><span class="pre">val</span></code> 和 <code class="docutils literal"><span class="pre">coll</span></code> 的第一个元素应用到 <code class="docutils literal"><span class="pre">f</span></code> ，得到的结果再和 <code class="docutils literal"><span class="pre">coll</span></code> 的第二个元素一起应用到 <code class="docutils literal"><span class="pre">f</span></code> ，以此类推。</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p><code class="docutils literal"><span class="pre">f</span></code> 应该是一个接受两个参数的函数，如果处理的 <code class="docutils literal"><span class="pre">coll</span></code> 可能为空，那么它还应该能进行无参数调用。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L6016">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reduce + </span><span class="p">[])</span>            <span class="c1">; coll 为空， + 返回无参数调用结果 0</span>
<span class="mi">0</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reduce + </span><span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>    <span class="c1">; coll 不为空</span>
<span class="mi">45</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reduce + </span><span class="mi">0</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>  <span class="c1">; coll 不为空，且给定 val</span>
<span class="mi">45</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/reductions"></span><div class="section" id="reductions">
<h3>reductions<a class="headerlink" href="#reductions" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(reductions f coll)</strong></div>
<div class="line"><strong>(reductions f init coll)</strong></div>
</div>
<p>返回一个惰性序列，
序列里包含计算 <code class="docutils literal"><span class="pre">(reduce</span> <span class="pre">f</span> <span class="pre">coll)</span></code> 所产生的所有中间结果。</p>
<p>如果给定了 <code class="docutils literal"><span class="pre">init</span></code> ，那么将它用作所有中间结果的初始值。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L6368">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">reduce + </span><span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="mi">10</span><span class="p">))</span>
<span class="mi">45</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">reductions</span> <span class="nb">+ </span><span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">6</span> <span class="mi">10</span> <span class="mi">15</span> <span class="mi">21</span> <span class="mi">28</span> <span class="mi">36</span> <span class="mi">45</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">reductions</span> <span class="nb">+ </span><span class="mi">0</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="mi">10</span><span class="p">))</span>    <span class="c1">; 注意 init 不止添加到序列头那么简单</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">6</span> <span class="mi">10</span> <span class="mi">15</span> <span class="mi">21</span> <span class="mi">28</span> <span class="mi">36</span> <span class="mi">45</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">reductions</span> <span class="nb">+ </span><span class="mi">10</span> <span class="p">(</span><span class="nb">range </span><span class="mi">1</span> <span class="mi">10</span><span class="p">))</span>   <span class="c1">; 它还作为每个中间值的初始化值</span>
<span class="p">(</span><span class="mi">10</span> <span class="mi">11</span> <span class="mi">13</span> <span class="mi">16</span> <span class="mi">20</span> <span class="mi">25</span> <span class="mi">31</span> <span class="mi">38</span> <span class="mi">46</span> <span class="mi">55</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/remove"></span><div class="section" id="remove">
<h3>remove<a class="headerlink" href="#remove" title="永久链接至标题">¶</a></h3>
<p><strong>(remove pred coll)</strong></p>
<p>返回一个惰性序列，
序列中包含 <code class="docutils literal"><span class="pre">coll</span></code> 里所有 <code class="docutils literal"><span class="pre">(pred</span> <span class="pre">item)</span></code> 测试结果为 <code class="docutils literal"><span class="pre">false</span></code> 的项。</p>
<p><code class="docutils literal"><span class="pre">pred</span></code> 必须是一个无副作用的函数。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 删除 0 - 9 中的所有偶数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">remove </span><span class="nv">even?</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">)</span>


<span class="c1">; 删除 0 - 9 中的所有奇数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">remove </span><span class="nv">odd?</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">6</span> <span class="mi">8</span><span class="p">)</span>


<span class="c1">; 删除 0 - 9 中所有大于等于 0 的数字，结果为空</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">remove </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">%</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nb">range </span><span class="mi">10</span><span class="p">))</span>
<span class="p">()</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/repeat"></span><div class="section" id="repeat">
<h3>repeat<a class="headerlink" href="#repeat" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(repeat x)</strong></div>
<div class="line"><strong>(repeat n x)</strong></div>
</div>
<p>返回一个包含 <code class="docutils literal"><span class="pre">n</span></code> 个 <code class="docutils literal"><span class="pre">x</span></code> 的惰性序列。</p>
<p>如果不指定 <code class="docutils literal"><span class="pre">n</span></code> ，那么值 <code class="docutils literal"><span class="pre">x</span></code> 可以被包含无限次。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 定义一个包含 10 个 &quot;hi&quot; 的惰性序列</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">ten-hi</span> <span class="p">(</span><span class="nb">repeat </span><span class="mi">10</span> <span class="s">&quot;hi&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/ten-hi</span>

<span class="nv">user=&gt;</span> <span class="nv">ten-hi</span>
<span class="p">(</span><span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span>


<span class="c1">; 定义一个包含无限个 &quot;hi&quot; 的惰性序列</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">infinite-hi</span> <span class="p">(</span><span class="nb">repeat </span><span class="s">&quot;hi&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/infinite-hi</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="nv">infinite-hi</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">20</span> <span class="nv">infinite-hi</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/repeatedly"></span><div class="section" id="repeatedly">
<h3>repeatedly<a class="headerlink" href="#repeatedly" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(repeatedly f)</strong></div>
<div class="line"><strong>(repeatedly n f)</strong></div>
</div>
<p>给定一个无参数的函数 <code class="docutils literal"><span class="pre">f</span></code> (通常带有副作用)，返回一个调用 <code class="docutils literal"><span class="pre">f</span></code> 函数 <code class="docutils literal"><span class="pre">n</span></code> 次的惰性序列。</p>
<p>如果不指定参数 <code class="docutils literal"><span class="pre">n</span></code> ，那么函数 <code class="docutils literal"><span class="pre">f</span></code> 可以执行无限次。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 测试函数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">greet</span> <span class="p">[]</span>
         <span class="s">&quot;hi!&quot;</span><span class="p">)</span>
<span class="o">#</span><span class="ss">&#39;user/greet</span>


<span class="c1">; 定义一个执行 10 次 greet 的惰性序列</span>
<span class="c1">; 并用 take 函数取出 5 个和 10 个 greet 的执行结果</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">ten-greet</span> <span class="p">(</span><span class="nf">repeatedly</span> <span class="mi">10</span> <span class="nv">greet</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/ten-greet</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">5</span> <span class="nv">ten-greet</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="nv">ten-greet</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span><span class="p">)</span>


<span class="c1">; 试图取出 10086 个值，但 ten-greet 最多只返回 10 个值</span>
<span class="c1">; 说明取出的数量最多只能和 n 一样大</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10086</span> <span class="nv">ten-greet</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span><span class="p">)</span>


<span class="c1">; 定义一个执行无限次 greet 的惰性序列</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">infinite-greet</span> <span class="p">(</span><span class="nf">repeatedly</span> <span class="nv">greet</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/infinite-greet</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">10</span> <span class="nv">infinite-greet</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">take </span><span class="mi">100</span> <span class="nv">infinite-greet</span><span class="p">)</span>
<span class="p">(</span><span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span> <span class="s">&quot;hi!&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/reverse"></span><div class="section" id="reverse">
<h3>reverse<a class="headerlink" href="#reverse" title="永久链接至标题">¶</a></h3>
<p><strong>(reverse coll)</strong></p>
<p>逆序给定的 <code class="docutils literal"><span class="pre">coll</span></code> 。</p>
<p>这个操作不是惰性(lazy)的。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="nf">user=&gt;</span><span class="p">(</span><span class="nb">reverse </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">(</span><span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/rseq"></span><div class="section" id="rseq">
<h3>rseq<a class="headerlink" href="#rseq" title="永久链接至标题">¶</a></h3>
<p><strong>(rseq rev)</strong></p>
<p>在常数时间内，返回 <code class="docutils literal"><span class="pre">rev</span></code> 的逆序序列。</p>
<p><code class="docutils literal"><span class="pre">rev</span></code> 只能是向量或者 sorted-map 。</p>
<p><code class="docutils literal"><span class="pre">rev</span></code> 为空时，返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 空向量和空 sorted-map</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rseq </span><span class="p">[])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rseq </span><span class="p">(</span><span class="nf">sorted-map</span><span class="p">))</span>
<span class="nv">nil</span>


<span class="c1">; 非空向量</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rseq </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1">; 非空 sorted-map</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">alpha</span> <span class="p">(</span><span class="nb">sorted-map </span><span class="ss">:a</span> <span class="s">&quot;apple&quot;</span> <span class="ss">:b</span> <span class="s">&quot;boy&quot;</span> <span class="ss">:c</span> <span class="s">&quot;cat&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/alpha</span>

<span class="nv">user=&gt;</span> <span class="nv">alpha</span>
<span class="p">{</span><span class="ss">:a</span> <span class="s">&quot;apple&quot;</span>, <span class="ss">:b</span> <span class="s">&quot;boy&quot;</span>, <span class="ss">:c</span> <span class="s">&quot;cat&quot;</span><span class="p">}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rseq </span><span class="nv">alpha</span><span class="p">)</span>
<span class="p">([</span><span class="ss">:c</span> <span class="s">&quot;cat&quot;</span><span class="p">]</span> <span class="p">[</span><span class="ss">:b</span> <span class="s">&quot;boy&quot;</span><span class="p">]</span> <span class="p">[</span><span class="ss">:a</span> <span class="s">&quot;apple&quot;</span><span class="p">])</span>


<span class="c1">; 一些不能处理的情况</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rseq </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="nv">ClassCastException</span> <span class="nv">clojure.lang.PersistentList</span> <span class="nv">cannot</span> <span class="nv">be</span> <span class="nb">cast </span><span class="nv">to</span> <span class="nv">clojure.lang.Reversible</span>  <span class="nv">clojure.core/rseq</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:1480</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">rseq </span><span class="nv">nil</span><span class="p">)</span>
<span class="nv">NullPointerException</span>   <span class="nv">clojure.core/rseq</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:1480</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/rsubseq"></span><div class="section" id="rsubseq">
<h3>rsubseq<a class="headerlink" href="#rsubseq" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(rsubseq sc test key)</strong></div>
<div class="line"><strong>(rsubseq sc start-test start-key end-test end-key)</strong></div>
</div>
<p>用法和 <cite>subseq</cite> 函数一样，但是返回的序列是逆序排序的。</p>
<p>等同于执行 <code class="docutils literal"><span class="pre">(rseq</span> <span class="pre">(subseq</span> <span class="pre">sc</span> <span class="pre">test</span> <span class="pre">key))</span></code> 或者 <code class="docutils literal"><span class="pre">(rseq</span> <span class="pre">(subseq</span> <span class="pre">sc</span> <span class="pre">start-test</span> <span class="pre">start-key</span> <span class="pre">end-test</span> <span class="pre">end-key))</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 测试数据</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">numbers</span> <span class="p">(</span><span class="nb">sorted-map </span><span class="mi">1</span> <span class="s">&quot;one&quot;</span> <span class="mi">2</span> <span class="s">&quot;two&quot;</span> <span class="mi">3</span> <span class="s">&quot;three&quot;</span> <span class="mi">4</span> <span class="s">&quot;four&quot;</span> <span class="mi">5</span> <span class="s">&quot;five&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/numbers</span>

<span class="nv">user=&gt;</span> <span class="nv">numbers</span>
<span class="p">{</span><span class="mi">1</span> <span class="s">&quot;one&quot;</span>, <span class="mi">2</span> <span class="s">&quot;two&quot;</span>, <span class="mi">3</span> <span class="s">&quot;three&quot;</span>, <span class="mi">4</span> <span class="s">&quot;four&quot;</span>, <span class="mi">5</span> <span class="s">&quot;five&quot;</span><span class="p">}</span>


<span class="c1">; 过滤所有键小于 1 大于 4 的键-值对，并逆序地返回结果</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">rsubseq</span> <span class="nv">numbers</span> <span class="nb">&gt;= </span><span class="mi">2</span> <span class="nb">&lt;= </span><span class="mi">4</span><span class="p">)</span>
<span class="p">([</span><span class="mi">4</span> <span class="s">&quot;four&quot;</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="s">&quot;three&quot;</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span> <span class="s">&quot;two&quot;</span><span class="p">])</span>


<span class="c1">; 过滤所有键小于 2 的键-值对，并逆序地返回结果</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">rsubseq</span> <span class="nv">numbers</span> <span class="nb">&gt; </span><span class="mi">2</span><span class="p">)</span>
<span class="p">([</span><span class="mi">5</span> <span class="s">&quot;five&quot;</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="s">&quot;four&quot;</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="s">&quot;three&quot;</span><span class="p">])</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/seq"></span><div class="section" id="seq">
<h3>seq<a class="headerlink" href="#seq" title="永久链接至标题">¶</a></h3>
<p><strong>(seq coll)</strong></p>
<p>根据给定的 <code class="docutils literal"><span class="pre">coll</span></code> ，返回一个相应的序列。</p>
<p>当 <code class="docutils literal"><span class="pre">coll</span></code> 为空时，返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">(sql</span> <span class="pre">nil)</span></code> 也返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">seq</span></code> 函数也可以作用于字符串、
（带有引用类型的）原生 Java 数组，
以及任何实现了 <code class="docutils literal"><span class="pre">iterable</span></code> 接口的对象。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 处理空向量和 nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq </span><span class="p">[])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">nil</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="c1">; 处理非空向量、列表、 Map 和字符串</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="nb">list </span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq </span><span class="p">{</span><span class="ss">:language</span> <span class="s">&quot;clojure&quot;</span> <span class="ss">:creator</span> <span class="s">&quot;Rich Hickey&quot;</span><span class="p">})</span>
<span class="p">([</span><span class="ss">:creator</span> <span class="s">&quot;Rich Hickey&quot;</span><span class="p">]</span> <span class="p">[</span><span class="ss">:language</span> <span class="s">&quot;clojure&quot;</span><span class="p">])</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">seq </span><span class="s">&quot;hello world&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="sc">\h</span> <span class="sc">\e</span> <span class="sc">\l</span> <span class="sc">\l</span> <span class="sc">\o</span> <span class="sc">\s</span><span class="nv">pace</span> <span class="sc">\w</span> <span class="sc">\o</span> <span class="sc">\r</span> <span class="sc">\l</span> <span class="sc">\d</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/shuffle"></span><div class="section" id="shuffle">
<h3>shuffle<a class="headerlink" href="#shuffle" title="永久链接至标题">¶</a></h3>
<p><strong>(shuffle coll)</strong></p>
<p>返回对 <code class="docutils literal"><span class="pre">coll</span></code> 进行乱序排列之后得出的序列。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">shuffle</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">[</span><span class="mi">4</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span><span class="p">]</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">shuffle</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/some"></span><div class="section" id="some">
<h3>some<a class="headerlink" href="#some" title="永久链接至标题">¶</a></h3>
<p><strong>(some pred coll)</strong></p>
<p>如果 <code class="docutils literal"><span class="pre">coll</span></code> 中有一个元素 <code class="docutils literal"><span class="pre">x</span></code> 能满足 <code class="docutils literal"><span class="pre">(pred</span> <span class="pre">x)</span></code> ，则返回``(pred x)``的值</p>
<p>如果 <code class="docutils literal"><span class="pre">coll</span></code> 中没有任何元素 <code class="docutils literal"><span class="pre">x</span></code> 能满足 <code class="docutils literal"><span class="pre">(pred</span> <span class="pre">x)</span></code> ，
返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<p>将一个集合用作 <code class="docutils literal"><span class="pre">pred</span></code> 是 <code class="docutils literal"><span class="pre">some</span></code> 的一个惯用法：
比如说，
<code class="docutils literal"><span class="pre">(some</span> <span class="pre">#{:fred}</span> <span class="pre">coll)</span></code> 在 <code class="docutils literal"><span class="pre">:fred</span></code> 存在于 <code class="docutils literal"><span class="pre">coll</span></code> 时返回 <code class="docutils literal"><span class="pre">:fred</span></code> ，
如果不存在，就返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">{</span><span class="ss">:fred</span><span class="p">}</span> <span class="p">[</span><span class="ss">:fred</span> <span class="ss">:peter</span> <span class="ss">:jack</span><span class="p">])</span>
<span class="ss">:fred</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">{</span><span class="ss">:mary</span><span class="p">}</span> <span class="p">[</span><span class="ss">:fred</span> <span class="ss">:peter</span> <span class="ss">:jack</span><span class="p">])</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">%</span> <span class="mi">10</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">])</span>            <span class="c1">; 查看是否有 &gt;= 10 的值存在</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">some </span><span class="o">#</span><span class="p">(</span><span class="nb">&gt;= </span><span class="nv">%</span> <span class="mi">5</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">9</span><span class="p">])</span>             <span class="c1">; 查看是否有 &gt;= 5 的值存在</span>
<span class="nv">true</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/sort"></span><div class="section" id="sort">
<h3>sort<a class="headerlink" href="#sort" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(sort coll)</strong></div>
<div class="line"><strong>(sort comparator coll)</strong></div>
</div>
<p>返回对 <code class="docutils literal"><span class="pre">coll</span></code> 进行排序之后得到的序列。</p>
<p>如果不指定 <code class="docutils literal"><span class="pre">comparator</span></code> ，
那么默认使用 <code class="docutils literal"><span class="pre">compare.</span></code> ，
<code class="docutils literal"><span class="pre">comparator</span></code> 必须实现 <code class="docutils literal"><span class="pre">java.util.Comparator</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">sort </span><span class="p">[</span><span class="mi">4</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">sort &gt;= </span><span class="p">[</span><span class="mi">4</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">4</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">sort &lt;= </span><span class="p">[</span><span class="mi">4</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/subseq"></span><div class="section" id="subseq">
<h3>subseq<a class="headerlink" href="#subseq" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(subseq sc test key)</strong></div>
<div class="line"><strong>(subseq sc start-test start-key end-test end-key)</strong></div>
</div>
<p>过滤 <code class="docutils literal"><span class="pre">sc</span></code> 并返回一个序列，序列里的所有实体(entry)的键 <code class="docutils literal"><span class="pre">ek</span></code> 都必须符合条件 <code class="docutils literal"><span class="pre">(true?</span> <span class="pre">(test</span> <span class="pre">(..</span> <span class="pre">sc</span> <span class="pre">comparator</span> <span class="pre">(compare</span> <span class="pre">ek</span> <span class="pre">key))</span> <span class="pre">0))</span></code> 。</p>
<p>如果没有任何实体符合条件，则返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<p>参数 <code class="docutils literal"><span class="pre">sc</span></code> 必须是一个 sorted collection ，测试条件 <code class="docutils literal"><span class="pre">test</span></code> 可以是 <code class="docutils literal"><span class="pre">&lt;</span></code> 、 <code class="docutils literal"><span class="pre">&lt;=</span></code> 、 <code class="docutils literal"><span class="pre">&gt;</span></code> 或者 <code class="docutils literal"><span class="pre">&gt;=</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 测试数据</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">numbers</span> <span class="p">(</span><span class="nb">sorted-map </span><span class="mi">1</span> <span class="s">&quot;one&quot;</span> <span class="mi">2</span> <span class="s">&quot;two&quot;</span> <span class="mi">3</span> <span class="s">&quot;three&quot;</span> <span class="mi">4</span> <span class="s">&quot;four&quot;</span> <span class="mi">5</span> <span class="s">&quot;five&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/numbers</span>

<span class="nv">user=&gt;</span> <span class="nv">numbers</span>
<span class="p">{</span><span class="mi">1</span> <span class="s">&quot;one&quot;</span>, <span class="mi">2</span> <span class="s">&quot;two&quot;</span>, <span class="mi">3</span> <span class="s">&quot;three&quot;</span>, <span class="mi">4</span> <span class="s">&quot;four&quot;</span>, <span class="mi">5</span> <span class="s">&quot;five&quot;</span><span class="p">}</span>


<span class="c1">; 过滤所有键小于 3 的键-值对</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">subseq</span> <span class="nv">numbers</span> <span class="nb">&gt;= </span><span class="mi">3</span><span class="p">)</span>
<span class="p">([</span><span class="mi">3</span> <span class="s">&quot;three&quot;</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="s">&quot;four&quot;</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span> <span class="s">&quot;five&quot;</span><span class="p">])</span>


<span class="c1">; 过滤所有键小于 1 大于 4 的键-值对</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">subseq</span> <span class="nv">numbers</span> <span class="nb">&gt;= </span><span class="mi">2</span> <span class="nb">&lt;= </span><span class="mi">4</span><span class="p">)</span>
<span class="p">([</span><span class="mi">2</span> <span class="s">&quot;two&quot;</span><span class="p">]</span> <span class="p">[</span><span class="mi">3</span> <span class="s">&quot;three&quot;</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span> <span class="s">&quot;four&quot;</span><span class="p">])</span>


<span class="c1">; 过滤所有键小于 10 的键-值对，返回 nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">subseq</span> <span class="nv">numbers</span> <span class="nb">&gt;= </span><span class="mi">10</span><span class="p">)</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/time"></span><div class="section" id="time">
<h3>time<a class="headerlink" href="#time" title="永久链接至标题">¶</a></h3>
<p><strong>(time expr)</strong></p>
<p>对 <code class="docutils literal"><span class="pre">expr</span></code> 进行求值，并打印求值所花费的时间。</p>
<p><code class="docutils literal"><span class="pre">expr</span></code> 的值作为函数的返回值被返回。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/d0c380d9809fd242bec688c7134e900f0bbedcac/src/clj/clojure/core.clj#L3424">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 计算对比两个关键字 100 次所需的时间</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">time</span>
         <span class="p">(</span><span class="nb">dotimes </span><span class="p">[</span><span class="nv">_</span> <span class="mi">100</span><span class="p">]</span>
           <span class="p">(</span><span class="nb">= </span><span class="ss">:kw</span> <span class="ss">:kw</span><span class="p">)))</span>
<span class="s">&quot;Elapsed time: 0.23802 msecs&quot;</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/tree-seq"></span><div class="section" id="tree-seq">
<h3>tree-seq<a class="headerlink" href="#tree-seq" title="永久链接至标题">¶</a></h3>
<p><strong>(tree-seq branch? children root)</strong></p>
<p>返回一个惰性序列，
序列里包含通过深度优先遍历得出的一棵树中的所有节点。</p>
<p><code class="docutils literal"><span class="pre">branch?</span></code> 函数接受一个参数，
通过向它传入一个节点，可以判断该节点是否拥有子节点。</p>
<p><code class="docutils literal"><span class="pre">children</span></code> 函数接受一个参数，
通过向它传入一个节点，可以得到一个包含该节点的所有子节点的序列。</p>
<p><code class="docutils literal"><span class="pre">children</span></code> 函数只会在那些
<code class="docutils literal"><span class="pre">branch?</span></code> 函数返回 <code class="docutils literal"><span class="pre">true</span></code> 的节点被调用。</p>
<p><code class="docutils literal"><span class="pre">root</span></code> 是树的根节点。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 函数 file-seq 用于列出一个文件夹的整个目录树</span>
<span class="c1">; 它是展示 tree-seq 用法的一个极好的例子</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">file-seq</span>
    <span class="p">[</span><span class="nv">dir</span><span class="p">]</span>
    <span class="p">(</span><span class="nf">tree-seq</span>
        <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="o">^</span><span class="nv">java.io.File</span> <span class="nv">f</span><span class="p">]</span> <span class="p">(</span><span class="k">. </span><span class="nv">f</span> <span class="p">(</span><span class="nf">isDirectory</span><span class="p">)))</span>      <span class="c1">; 检查文件 f 是不是一个文件夹</span>
        <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="o">^</span><span class="nv">java.io.File</span> <span class="nv">d</span><span class="p">]</span> <span class="p">(</span><span class="nb">seq </span><span class="p">(</span><span class="k">. </span><span class="nv">d</span> <span class="p">(</span><span class="nf">listFiles</span><span class="p">))))</span>  <span class="c1">; 如果是的话，就用 listFiles 方法遍历它</span>
        <span class="nv">dir</span><span class="p">))</span>                                           <span class="c1">; 树的根节点是传入的文件夹</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/vals"></span><div class="section" id="vals">
<h3>vals<a class="headerlink" href="#vals" title="永久链接至标题">¶</a></h3>
<p><strong>(vals map)</strong></p>
<p>返回一个序列，序列里包含给定 <code class="docutils literal"><span class="pre">map</span></code> 的所有值(value)。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 空 Map</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">vals </span><span class="p">{})</span>
<span class="nv">nil</span>

<span class="c1">; 非空 Map</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">vals </span><span class="p">{</span><span class="ss">:python</span> <span class="s">&quot;Guido&quot;</span> <span class="ss">:clojure</span> <span class="s">&quot;Rich&quot;</span> <span class="ss">:ruby</span> <span class="s">&quot;Matz&quot;</span><span class="p">})</span>
<span class="p">(</span><span class="s">&quot;Guido&quot;</span> <span class="s">&quot;Matz&quot;</span> <span class="s">&quot;Rich&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/when-let"></span><div class="section" id="when-let">
<h3>when-let<a class="headerlink" href="#when-let" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(when-let bindings &amp; body)</strong></div>
<div class="line"><strong>bindings =&gt; binding-form test</strong></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">test</span></code> 的值 <code class="docutils literal"><span class="pre">value</span></code> 为真，那么结合 <code class="docutils literal"><span class="pre">binding-form</span></code> 绑定，对 <code class="docutils literal"><span class="pre">body</span></code> 进行求值。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="kd">defn </span><span class="nv">drop-one</span> <span class="p">[</span><span class="nv">coll</span><span class="p">]</span>
           <span class="p">(</span><span class="nb">when-let </span><span class="p">[</span><span class="nv">s</span> <span class="p">(</span><span class="nb">seq </span><span class="nv">coll</span><span class="p">)]</span>
               <span class="p">(</span><span class="nb">rest </span><span class="nv">s</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/drop-one</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">drop-one</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/when-not"></span><div class="section" id="when-not">
<h3>when-not<a class="headerlink" href="#when-not" title="永久链接至标题">¶</a></h3>
<p><strong>(when-not test &amp; body)</strong></p>
<p>对 <code class="docutils literal"><span class="pre">test</span></code> 部分进行求值，如果结果为 <code class="docutils literal"><span class="pre">false</span></code> ，那么在一个隐式 <code class="docutils literal"><span class="pre">do</span></code> 的包围下对 <code class="docutils literal"><span class="pre">body</span></code> 进行求值。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">when-not </span><span class="nv">true</span>
           <span class="p">(</span><span class="nb">println </span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">println </span><span class="s">&quot;moto&quot;</span><span class="p">))</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">when-not </span><span class="nv">false</span>
           <span class="p">(</span><span class="nb">println </span><span class="s">&quot;hello&quot;</span><span class="p">)</span>
           <span class="p">(</span><span class="nb">println </span><span class="s">&quot;moto&quot;</span><span class="p">))</span>
<span class="nv">hello</span>
<span class="nv">moto</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/with-open"></span><div class="section" id="with-open">
<h3>with-open<a class="headerlink" href="#with-open" title="永久链接至标题">¶</a></h3>
<p><strong>(with-open bindings &amp; body)</strong></p>
<p>在绑定了名字 <code class="docutils literal"><span class="pre">name</span></code> 与初始值 <code class="docutils literal"><span class="pre">init</span></code> 的 <code class="docutils literal"><span class="pre">try</span></code> 表达式里面对 <code class="docutils literal"><span class="pre">body</span></code> 进行求值
并按照绑定时间从晚到早的顺序
在 <code class="docutils literal"><span class="pre">finally</span></code> 语句里面对每个 <code class="docutils literal"><span class="pre">name</span></code> 执行 <code class="docutils literal"><span class="pre">(.close</span> <span class="pre">name)</span></code> 调用</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="kd">ns </span><span class="nv">io</span>
  <span class="p">(</span><span class="ss">:require</span> <span class="p">[</span><span class="nv">clojure.java.io</span> <span class="ss">:as</span> <span class="nv">io</span><span class="p">]))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">readLineByLine</span> <span class="p">[</span><span class="nv">file-name</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">reader</span> <span class="p">(</span><span class="nf">io/reader</span> <span class="nv">file-name</span><span class="p">)]</span>
    <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">line</span> <span class="p">(</span><span class="nb">line-seq </span><span class="nv">reader</span><span class="p">)]</span>
      <span class="p">(</span><span class="nb">println </span><span class="nv">line</span><span class="p">))))</span>

<span class="p">(</span><span class="kd">defn </span><span class="nv">copyLineByLine</span> <span class="p">[</span><span class="nv">source</span> <span class="nv">target</span><span class="p">]</span>
  <span class="p">(</span><span class="nb">with-open </span><span class="p">[</span><span class="nv">reader</span> <span class="p">(</span><span class="nf">io/reader</span> <span class="nv">source</span><span class="p">)</span>
              <span class="nv">writer</span> <span class="p">(</span><span class="nf">io/writer</span> <span class="nv">target</span><span class="p">)]</span>
    <span class="p">(</span><span class="nf">io/copy</span> <span class="nv">reader</span> <span class="nv">writer</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/xml-seq"></span><div class="section" id="xml-seq">
<h3>xml-seq<a class="headerlink" href="#xml-seq" title="永久链接至标题">¶</a></h3>
<p><strong>(xml-seq root)</strong></p>
<p>返回一个惰性序列，序列里包含一棵 xml 元素树。</p>
<p>xml 文件可以用 <code class="docutils literal"><span class="pre">clojure.xml/parse</span></code> 函数解释。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 解释一个 xml 文件，并提取内容</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;clojure.xml</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">content</span> <span class="p">(</span><span class="nf">clojure.xml/parse</span> <span class="s">&quot;http://www.w3schools.com/xml/note.xml&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/content</span>

<span class="c1">; 根据 xml 内容，生成 xml 树</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">tree</span> <span class="p">(</span><span class="nb">xml-seq </span><span class="nv">content</span><span class="p">))</span>
<span class="o">#</span><span class="ss">&#39;user/tree</span>

<span class="nv">user=&gt;</span> <span class="nv">tree</span>
<span class="p">({</span><span class="ss">:tag</span> <span class="ss">:note</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[{</span><span class="ss">:tag</span> <span class="ss">:to</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Tove&quot;</span><span class="p">]}</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:from</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Jani&quot;</span><span class="p">]}</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:heading</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Reminder&quot;</span><span class="p">]}</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:body</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Don&#39;t forget me this weekend!&quot;</span><span class="p">]}]}</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:to</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Tove&quot;</span><span class="p">]}</span> <span class="s">&quot;Tove&quot;</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:from</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Jani&quot;</span><span class="p">]}</span> <span class="s">&quot;Jani&quot;</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:heading</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Reminder&quot;</span><span class="p">]}</span> <span class="s">&quot;Reminder&quot;</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:body</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Don&#39;t forget me this weekend!&quot;</span><span class="p">]}</span> <span class="s">&quot;Don&#39;t forget me this weekend!&quot;</span><span class="p">)</span>


<span class="c1">; 遍历树</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">tree</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:tag</span> <span class="ss">:note</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[{</span><span class="ss">:tag</span> <span class="ss">:to</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Tove&quot;</span><span class="p">]}</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:from</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Jani&quot;</span><span class="p">]}</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:heading</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Reminder&quot;</span><span class="p">]}</span> <span class="p">{</span><span class="ss">:tag</span> <span class="ss">:body</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Don&#39;t forget me this weekend!&quot;</span><span class="p">]}]}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">tree</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:tag</span> <span class="ss">:to</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Tove&quot;</span><span class="p">]}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">tree</span> <span class="mi">2</span><span class="p">)</span>
<span class="s">&quot;Tove&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">tree</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">{</span><span class="ss">:tag</span> <span class="ss">:from</span>, <span class="ss">:attrs</span> <span class="nv">nil</span>, <span class="ss">:content</span> <span class="p">[</span><span class="s">&quot;Jani&quot;</span><span class="p">]}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">nth </span><span class="nv">tree</span> <span class="mi">4</span><span class="p">)</span>
<span class="s">&quot;Jani&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.core/zipmap"></span><div class="section" id="zipmap">
<h3>zipmap<a class="headerlink" href="#zipmap" title="永久链接至标题">¶</a></h3>
<p><strong>(zipmap keys vals)</strong></p>
<p>返回一个含有键和相应值的map</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">zipmap </span><span class="p">[</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span> <span class="ss">:d</span> <span class="ss">:e</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])</span>
<span class="p">{</span><span class="ss">:e</span> <span class="mi">5</span>, <span class="ss">:d</span> <span class="mi">4</span>, <span class="ss">:c</span> <span class="mi">3</span>, <span class="ss">:b</span> <span class="mi">2</span>, <span class="ss">:a</span> <span class="mi">1</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.core.async/index"></span><div class="section" id="clojure-core-async">
<h2>clojure.core.async<a class="headerlink" href="#clojure-core-async" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.core.async/buffer"></span><div class="section" id="buffer">
<h3>buffer<a class="headerlink" href="#buffer" title="永久链接至标题">¶</a></h3>
<p><strong>(buffer n)</strong></p>
<p>返回一个大小固定为n的buffer，当buffer满了的时候，put操作会阻塞</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">c</span> <span class="p">(</span><span class="nf">chan</span> <span class="p">(</span><span class="nf">buffer</span> <span class="mi">3</span><span class="p">)))</span>
<span class="o">#</span><span class="ss">&#39;user/c</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.data/index"></span><div class="section" id="clojure-data">
<h2>clojure.data<a class="headerlink" href="#clojure-data" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.data/diff"></span><div class="section" id="diff">
<h3>diff<a class="headerlink" href="#diff" title="永久链接至标题">¶</a></h3>
<p><strong>(diff a b)</strong></p>
<p>递归比较a和b，返回一个tuple 结构如
[只在a中出现的元素  只在b中出现的元素  a和b中共同出现的元素]</p>
<p>比较规则:
* a和b相等 返回[nil,nil,a]
* Map键值相同值不同视为不同
* Set无法比较差异
* 所有的序列都被视为索引的关联集合，结果以向量的类型返回
* 所有东西(包含string)都视为原子且平等比较</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.data</span><span class="p">)</span>
<span class="p">(</span><span class="k">def </span><span class="nv">uno</span> <span class="p">{</span><span class="ss">:same</span> <span class="s">&quot;same&quot;</span>, <span class="ss">:different</span> <span class="s">&quot;one&quot;</span><span class="p">})</span>
<span class="p">(</span><span class="k">def </span><span class="nv">dos</span> <span class="p">{</span><span class="ss">:same</span> <span class="s">&quot;same&quot;</span>, <span class="ss">:different</span> <span class="s">&quot;two&quot;</span>, <span class="ss">:onlyhere</span> <span class="s">&quot;whatever&quot;</span><span class="p">})</span>
<span class="p">(</span><span class="nf">diff</span> <span class="nv">uno</span> <span class="nv">dos</span><span class="p">)</span>
<span class="nv">=&gt;</span> <span class="p">({</span><span class="ss">:different</span> <span class="s">&quot;one&quot;</span><span class="p">}</span> <span class="p">{</span><span class="ss">:onlyhere</span> <span class="s">&quot;whatever&quot;</span>, <span class="ss">:different</span> <span class="s">&quot;two&quot;</span><span class="p">}</span> <span class="p">{</span><span class="ss">:same</span> <span class="s">&quot;same&quot;</span><span class="p">})</span>
<span class="c1">;;  {uno中出现的元素 } {           dos中出现的元素            } {两者均有的元素}</span>

<span class="p">(</span><span class="nf">diff</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">})</span>
<span class="nv">=&gt;</span> <span class="p">(</span><span class="nf">nil</span> <span class="p">{</span><span class="ss">:b</span> <span class="mi">2</span><span class="p">}</span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span><span class="p">})</span>
<span class="c1">;; 并没有只在第一个集合中存在的元素</span>


<span class="p">(</span><span class="nf">diff</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span> <span class="mi">9</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">])</span>              <span class="c1">;;=&gt; [[1 2] [5 9 nil 2 3 7] [nil nil 3]]</span>
<span class="p">(</span><span class="nf">diff</span> <span class="p">(</span><span class="nb">set </span><span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">])</span> <span class="p">(</span><span class="nb">set </span><span class="p">[</span><span class="mi">5</span> <span class="mi">9</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">]))</span>  <span class="c1">;;=&gt; [#{1}  #{7 9 5}        #{3 2}]</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.pprint/index"></span><div class="section" id="clojure-pprint">
<h2>clojure.pprint<a class="headerlink" href="#clojure-pprint" title="永久链接至标题">¶</a></h2>
<div class="line-block">
<div class="line"><strong>(A Pretty Printer for Clojure)</strong></div>
</div>
<p>clojure.pprint 实现了一个灵活的工具，用于把clojure的数据结构输出成优雅易懂的格式。pretty printer最基本的使用方式，就是把代码中的 println 替换成 pprint。高级用户可以通过 the building blocks 来定制自己的输出格式。</p>
<p>pprint 对基础的数据提供了简单的格式，对 clojure source code 提供了专有的格式。其他更高级的格式，包括完全不像 clojure 惯用的数据格式的 XML ，JSON ，都可以通过自定义补丁来输出出来。</p>
<p>这个模块不仅包括 pprint， 也包括给 Common lisp 提供支持的 cl-format。因为 pprint 和 cl－format 需要共同作用，所以 pprint 支持非常简洁的自定义补丁。除此之外， pprint 也提供了 format function 作为 clojure 现有的标准 format function的一个替代。</p>
<p>欢迎查看 pprint 和 cl-format 的文档来获取更多的信息。</p>
<p>Added in Clojure version 1.2</p>
<div class="toctree-wrapper compound">
<span id="document-clojure.pprint/cl-format"></span><div class="section" id="cl-format">
<h3>cl-format<a class="headerlink" href="#cl-format" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(cl-format writer format-in &amp; args)</strong></div>
</div>
<p>Common Lisp 兼容的格式输出的函数的实现。cl-format
的格式包括是输出到流里还是输出
成string都是通过不同的参数控制的。它支持极为复杂的机构化的数据。</p>
<p>Writer参数是java.io.Writer的一个实例，有的话输出成流，反之输出成String。format-in
用于格式控制。 args 指代数据将要被格式化输出的。</p>
<p>format control string
是通过格式化符号，标注怎么去把许多参数按不同的方式格式化的。
类似 String.format 的 dsl。</p>
<p>如果 writer 是控制，那么cl-format 返回 string，否则返回空值，输出到流里。</p>
<p>一个例子:
(let [results [46 38 22]]
(cl-format true &#8220;There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^,
~}~%&#8221;
(count results) results))</p>
<p>输出结果 <em>out</em>:
There are 3 results: 46, 38, 22</p>
<p>详细的文档关于 format control string 在&#8221;Common
Lisp the Language, 2nd edition&#8221;, Chapter 22
(available online at:
<a class="reference external" href="http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000">http://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000</a>)
and in the Common Lisp HyperSpec at
<a class="reference external" href="http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm">http://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm</a></p>
<p>1 EXAMPLE</p>
<div class="highlight-clojure"><div class="highlight"><pre>;; 一种格式化integer的方式.
;; 第一个参数把输出定向到 *out*
user=&gt; (cl-format true &quot;~5d\n&quot; 3)
3
nil

;; 第一个参数nil或false回直接输出成sting
user=&gt; (cl-format nil &quot;~5d&quot; 3)
&quot;    3&quot;

user=&gt; (cl-format nil &quot;Pad with leading zeros ~5,&#39;0d&quot; 3)
&quot;Pad with leading zeros 00003&quot;

user=&gt; (cl-format nil &quot;Pad with leading asterisks ~5,&#39;*d&quot; 3)
&quot;Pad with leading asterisks ****3&quot;


;; 如果有办法去描述一个左对齐的数在一个 formatString 里请标示在这理。
;; 这个任务在我看来，可以首先去 formatted 数成 String 然后再使用 &lt;width&gt;
规则加到原来的输出结果上。

user=&gt; (cl-format nil &quot;~15a&quot; (cl-format nil &quot;~:d&quot; 1234567))
&quot;1,234,567      &quot;

user=&gt; (cl-format nil &quot;Always print the sign ~5@d&quot; 3)
&quot;Always print the sign    +3&quot;

user=&gt; (cl-format nil &quot;Use comma group-separator every 3 digits ~12:d&quot; 1234567)
&quot;Use comma group-separator every 3 digits 1,234,567&quot;

user=&gt; (cl-format nil &quot;decimal ~d  binary ~b octal ~o  hex ~x&quot; 63 63 63 63)
&quot;decimal 63  binary 111111  octal 77  hex 3f&quot;

user=&gt; (cl-format nil &quot;base 7  ~7r  with width and zero pad  ~7,15,&#39;0r&quot; 63 63)
&quot;base 7  120  with width and zero pad 000000000000120&quot;

;; 在 cl-format 里不需要做任何转换  BigInt,
;; BigInteger, or BigDecimal.
user=&gt; (cl-format nil &quot;cl-format handle   BigInts ~15d&quot; 12345678901234567890)
&quot;cl-format handles BigInts
12345678901234567890&quot;

user=&gt; (cl-format nil &quot;Be aware of auto-conversion  ~8,&#39;0d  ~8,&#39;0d&quot; 2.4 -5/4)
&quot;Be aware of auto-conversion  000002.4
0000-5/4&quot;

;; 下面看起来可能像是一个bug，但是是被 Common Lisp HyperSpec 写在文档上的一种方法，如果你觉得这样写不爽，
;; 你也可以这样写 (format &quot;%08d&quot; -2)

user=&gt; (cl-format nil &quot;~8,&#39;0d&quot; -2)
&quot;000000-2&quot;
</pre></div>
</div>
</div>
<span id="document-clojure.pprint/pp"></span><div class="section" id="pp">
<h3>pp<a class="headerlink" href="#pp" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(macro)</strong></div>
</div>
<p>使用宏去调用 pprint 打印上一次的输出。等价于 <code class="docutils literal"><span class="pre">(pprint</span> <span class="pre">*1)</span></code> 。</p>
<p>添加于 Clojure 1.2 版本。</p>
</div>
</div>
</div>
<span id="document-clojure.string/index"></span><div class="section" id="clojure-string">
<h2>clojure.string<a class="headerlink" href="#clojure-string" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.string/blank"></span><div class="section" id="blank">
<h3>blank?<a class="headerlink" href="#blank" title="永久链接至标题">¶</a></h3>
<p><strong>(blank? s)</strong></p>
<p>如果 <code class="docutils literal"><span class="pre">s</span></code> 是 <code class="docutils literal"><span class="pre">nil</span></code> 、空字符串 <code class="docutils literal"><span class="pre">&quot;&quot;</span></code> 或者只包含空白的字符串，那么返回 <code class="docutils literal"><span class="pre">true</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/blank?</span> <span class="nv">nil</span><span class="p">)</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/blank?</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/blank?</span> <span class="s">&quot;    &quot;</span><span class="p">)</span>
<span class="nv">true</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/blank?</span> <span class="s">&quot;hello world&quot;</span><span class="p">)</span>
<span class="nv">false</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/reverse"></span><div class="section" id="reverse">
<h3>reverse<a class="headerlink" href="#reverse" title="永久链接至标题">¶</a></h3>
<p><strong>(reverse s)</strong></p>
<p>返回字符串 <code class="docutils literal"><span class="pre">s</span></code> 的逆序版本。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/reverse</span> <span class="s">&quot;clojure&quot;</span><span class="p">)</span>
<span class="s">&quot;erujolc&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/escape"></span><div class="section" id="escape">
<h3>escape<a class="headerlink" href="#escape" title="永久链接至标题">¶</a></h3>
<p><strong>(escape s cmap)</strong></p>
<p>使用函数 <code class="docutils literal"><span class="pre">cmap</span></code> 对字符串 <code class="docutils literal"><span class="pre">s</span></code> 中的每个字符 <code class="docutils literal"><span class="pre">ch</span></code> 进行转义，并返回一个新字符串。</p>
<p>转义按照以下规则进行：</p>
<ul class="simple">
<li>如果 <code class="docutils literal"><span class="pre">(cmap</span> <span class="pre">ch)</span></code> 返回 <code class="docutils literal"><span class="pre">nil</span></code> ，那么将 <code class="docutils literal"><span class="pre">ch</span></code> 添加到新字符串</li>
<li>如果 <code class="docutils literal"><span class="pre">(cmap</span> <span class="pre">ch)</span></code> 不为 <code class="docutils literal"><span class="pre">nil</span></code> ，那么将 <code class="docutils literal"><span class="pre">(str</span> <span class="pre">(cmap</span> <span class="pre">ch))</span></code> 添加到新字符串。</li>
</ul>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/escape</span> <span class="s">&quot;I want 1 &lt; 2 as HTML, &amp; other good things.&quot;</span> <span class="p">{</span><span class="sc">\&lt;</span> <span class="s">&quot;&amp;lt;&quot;</span> <span class="sc">\&gt;</span> <span class="s">&quot;&amp;gt;&quot;</span> <span class="sc">\&amp;</span> <span class="s">&quot;&amp;amp;&quot;</span><span class="p">})</span>
<span class="s">&quot;I want 1 &amp;lt; 2 as HTML, &amp;amp; other good things.&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/replace"></span><div class="section" id="replace">
<h3>replace<a class="headerlink" href="#replace" title="永久链接至标题">¶</a></h3>
<p><strong>(replace s match replacement)</strong></p>
<p>将字符串 <code class="docutils literal"><span class="pre">s</span></code> 中的所有 <code class="docutils literal"><span class="pre">match</span></code> 实例（instance）替换成 <code class="docutils literal"><span class="pre">replacement</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">match</span></code> / <code class="docutils literal"><span class="pre">replacement</span></code> 可以是以下组合：</p>
<ol class="arabic simple">
<li>字符串 / 字符串</li>
<li>字符 / 字符</li>
<li>模式（pattern） / 字符串或一个函数，其中函数的参数为模式所匹配的实例</li>
</ol>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 组合 1 ：用字符串替换字符串</span>
<span class="c1">; 将字符串里的子串 moto 替换成 google</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/replace</span> <span class="s">&quot;hello moto&quot;</span> <span class="s">&quot;moto&quot;</span> <span class="s">&quot;google&quot;</span><span class="p">)</span>
<span class="s">&quot;hello google&quot;</span>

<span class="c1">; 组合 2 ：用字符替换字符</span>
<span class="c1">; 将字符串的所有小写 o 替换成大写 O</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/replace</span> <span class="s">&quot;hello moto&quot;</span> <span class="s">&quot;o&quot;</span> <span class="s">&quot;O&quot;</span><span class="p">)</span>
<span class="s">&quot;hellO mOtO&quot;</span>

<span class="c1">; 组合 3 ：用字符串替换匹配模式的实例</span>
<span class="c1">; 将匹配 #&quot;red&quot; 模式的实例替换为 &quot;blue&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/replace</span> <span class="s">&quot;The color is red&quot;</span> <span class="o">#</span><span class="s">&quot;red&quot;</span> <span class="s">&quot;blue&quot;</span><span class="p">)</span>
<span class="s">&quot;The color is blue&quot;</span>

<span class="c1">; 另一个组合 3 ：用给定函数的返回值来替换匹配模式的实例</span>
<span class="c1">; 将字符串里的所有原音字母转换为大写</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/replace</span> <span class="s">&quot;The color is red&quot;</span> <span class="o">#</span><span class="s">&quot;[aeiou]&quot;</span> <span class="nv">clojure.string/upper-case</span><span class="p">)</span>
<span class="s">&quot;ThE cOlOr Is rEd&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/replace-first"></span><div class="section" id="replace-first">
<h3>replace-first<a class="headerlink" href="#replace-first" title="永久链接至标题">¶</a></h3>
<p><strong>(replace-first s match replacement)</strong></p>
<p>和 <cite>replace</cite> 函数的作用类似，但只替换 <code class="docutils literal"><span class="pre">match</span></code> 的第一个实例。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 只有第一个匹配的原音 e 被转为大写字母了</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/replace-first</span> <span class="s">&quot;The color is red&quot;</span> <span class="o">#</span><span class="s">&quot;[aeiou]&quot;</span> <span class="nv">clojure.string/upper-case</span><span class="p">)</span>
<span class="s">&quot;ThE color is red&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/capitalize"></span><div class="section" id="capitalize">
<h3>capitalize<a class="headerlink" href="#capitalize" title="永久链接至标题">¶</a></h3>
<p><strong>(capitalize s)</strong></p>
<p>将字符串 <code class="docutils literal"><span class="pre">s</span></code> 的首个字符转换成大写，剩余的其他字符全部转换为小写。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/capitalize</span> <span class="s">&quot;hello world&quot;</span><span class="p">)</span>
<span class="s">&quot;Hello world&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/capitalize</span> <span class="s">&quot;HELLO WORLD&quot;</span><span class="p">)</span>
<span class="s">&quot;Hello world&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/lower-case"></span><div class="section" id="lower-case">
<h3>lower-case<a class="headerlink" href="#lower-case" title="永久链接至标题">¶</a></h3>
<p><strong>(lower-case s)</strong></p>
<p>将字符串 <code class="docutils literal"><span class="pre">s</span></code> 的所有字符转换为小写。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/lower-case</span> <span class="s">&quot;hello moto&quot;</span><span class="p">)</span>
<span class="s">&quot;hello moto&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/lower-case</span> <span class="s">&quot;HELLO MOTO&quot;</span><span class="p">)</span>
<span class="s">&quot;hello moto&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/upper-case"></span><div class="section" id="upper-case">
<h3>upper-case<a class="headerlink" href="#upper-case" title="永久链接至标题">¶</a></h3>
<p><strong>(upper-case s)</strong></p>
<p>将字符串 <code class="docutils literal"><span class="pre">s</span></code> 的所有字符转换为大写。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/upper-case</span> <span class="s">&quot;hello moto&quot;</span><span class="p">)</span>
<span class="s">&quot;HELLO MOTO&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/upper-case</span> <span class="s">&quot;HELLO MOTO&quot;</span><span class="p">)</span>
<span class="s">&quot;HELLO MOTO&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/join"></span><div class="section" id="join">
<h3>join<a class="headerlink" href="#join" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(join coll)</strong></div>
<div class="line"><strong>(join separator coll)</strong></div>
</div>
<p>先使用 <code class="docutils literal"><span class="pre">(seq</span> <span class="pre">coll)</span></code> 将 <code class="docutils literal"><span class="pre">coll</span></code> 转换为序列，然后返回一个包含序列里所有元素的字符串。</p>
<p>多个元素之间以一个可选的 <code class="docutils literal"><span class="pre">separator</span></code> 分隔开。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">fruit</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span> <span class="s">&quot;banana&quot;</span> <span class="s">&quot;cherry&quot;</span><span class="p">])</span>
<span class="o">#</span><span class="ss">&#39;user/fruit</span>

<span class="c1">; 不使用 separator</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/join</span> <span class="nv">fruit</span><span class="p">)</span>
<span class="s">&quot;applebananacherry&quot;</span>

<span class="c1">; 使用 &quot;, &quot; 作为 separator</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/join</span> <span class="s">&quot;, &quot;</span> <span class="nv">fruit</span><span class="p">)</span>
<span class="s">&quot;apple, banana, cherry&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/split"></span><div class="section" id="split">
<h3>split<a class="headerlink" href="#split" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(split s re)</strong></div>
<div class="line"><strong>(split s re limit)</strong></div>
</div>
<p>根据正则表达式 <code class="docutils literal"><span class="pre">re</span></code> ，对字符串 <code class="docutils literal"><span class="pre">s</span></code> 进行分割，结果所得的一个或多个字符串保存在一个向量里面。</p>
<p>可选的 <code class="docutils literal"><span class="pre">limit</span></code> 参数指定最大的分割次数。</p>
<p>这个函数不是惰性的。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">; 分割 #&quot;\r?\n&quot; 是 clojure.string/split-lines 的定义</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/split</span> <span class="s">&quot;hello\nmoto\r\nagain\r\n&quot;</span> <span class="o">#</span><span class="s">&quot;\r?\n&quot;</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span> <span class="s">&quot;again&quot;</span><span class="p">]</span>

<span class="c1">; 带 limit 参数</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/split</span> <span class="s">&quot;hello\nmoto\r\nagain\r\n&quot;</span> <span class="o">#</span><span class="s">&quot;\r?\n&quot;</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;hello\nmoto\r\nagain\r\n&quot;</span><span class="p">]</span>

<span class="nv">user=&gt;</span>  <span class="p">(</span><span class="nf">clojure.string/split</span> <span class="s">&quot;hello\nmoto\r\nagain\r\n&quot;</span> <span class="o">#</span><span class="s">&quot;\r?\n&quot;</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto\r\nagain\r\n&quot;</span><span class="p">]</span>

<span class="nv">user=&gt;</span>  <span class="p">(</span><span class="nf">clojure.string/split</span> <span class="s">&quot;hello\nmoto\r\nagain\r\n&quot;</span> <span class="o">#</span><span class="s">&quot;\r?\n&quot;</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span> <span class="s">&quot;again\r\n&quot;</span><span class="p">]</span>

<span class="nv">user=&gt;</span>  <span class="p">(</span><span class="nf">clojure.string/split</span> <span class="s">&quot;hello\nmoto\r\nagain\r\n&quot;</span> <span class="o">#</span><span class="s">&quot;\r?\n&quot;</span> <span class="mi">4</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span> <span class="s">&quot;again&quot;</span> <span class="s">&quot;&quot;</span><span class="p">]</span>

<span class="nv">user=&gt;</span>  <span class="p">(</span><span class="nf">clojure.string/split</span> <span class="s">&quot;hello\nmoto\r\nagain\r\n&quot;</span> <span class="o">#</span><span class="s">&quot;\r?\n&quot;</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span> <span class="s">&quot;again&quot;</span> <span class="s">&quot;&quot;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/split-lines"></span><div class="section" id="split-lines">
<h3>split-lines<a class="headerlink" href="#split-lines" title="永久链接至标题">¶</a></h3>
<p><strong>(split-lines s)</strong></p>
<p>在字符串 <code class="docutils literal"><span class="pre">s</span></code> 的 <code class="docutils literal"><span class="pre">\n</span></code> 或者 <code class="docutils literal"><span class="pre">\r\n</span></code> 处分割开。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/split-lines</span> <span class="s">&quot;hello\nmoto\r\nagain\r\n&quot;</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span> <span class="s">&quot;again&quot;</span><span class="p">]</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/split-lines</span> <span class="s">&quot;no-new-lines&quot;</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;no-new-lines&quot;</span><span class="p">]</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/split-lines</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">]</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/split-lines</span> <span class="nv">nil</span><span class="p">)</span>
<span class="c1">;NullPointerException   java.util.regex.Matcher.getTextLength (Matcher.java:1234)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/trim"></span><div class="section" id="trim">
<h3>trim<a class="headerlink" href="#trim" title="永久链接至标题">¶</a></h3>
<p>从字符串的两端移除空白。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/trim</span> <span class="s">&quot;clojure&quot;</span><span class="p">)</span>
<span class="s">&quot;clojure&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/trim</span> <span class="s">&quot;    clojure    &quot;</span><span class="p">)</span>
<span class="s">&quot;clojure&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/triml"></span><div class="section" id="triml">
<h3>triml<a class="headerlink" href="#triml" title="永久链接至标题">¶</a></h3>
<p><strong>(triml s)</strong></p>
<p>移除字符串 <code class="docutils literal"><span class="pre">s</span></code> 左端的空白。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/triml</span> <span class="s">&quot;    clojure    &quot;</span><span class="p">)</span>
<span class="s">&quot;clojure    &quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/trimr"></span><div class="section" id="trimr">
<h3>trimr<a class="headerlink" href="#trimr" title="永久链接至标题">¶</a></h3>
<p><strong>(trimr s)</strong></p>
<p>移除字符串 <code class="docutils literal"><span class="pre">s</span></code> 右端的空白。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/trimr</span> <span class="s">&quot;    clojure    &quot;</span><span class="p">)</span>
<span class="s">&quot;    clojure&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.string/trim-newline"></span><div class="section" id="trim-newline">
<h3>trim-newline<a class="headerlink" href="#trim-newline" title="永久链接至标题">¶</a></h3>
<p><strong>(trim-newline s)</strong></p>
<p>从字符串的末尾移除转行符 <code class="docutils literal"><span class="pre">\n</span></code> 和返回符 <code class="docutils literal"><span class="pre">\r</span></code> 。</p>
<p>类似于 Perl 的 <code class="docutils literal"><span class="pre">chomp</span></code> 函数。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/trim-newline</span> <span class="s">&quot;test\n&quot;</span><span class="p">)</span>
<span class="s">&quot;test&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/trim-newline</span> <span class="s">&quot;test\r&quot;</span><span class="p">)</span>
<span class="s">&quot;test&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/trim-newline</span> <span class="s">&quot;test\n\r&quot;</span><span class="p">)</span>
<span class="s">&quot;test&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/trim-newline</span> <span class="s">&quot;test\r\n&quot;</span><span class="p">)</span>
<span class="s">&quot;test&quot;</span>

<span class="c1">; 只移除末尾的换行符</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.string/trim-newline</span> <span class="s">&quot;leading newline\n trailing newline\n&quot;</span><span class="p">)</span>
<span class="s">&quot;leading newline\n trailing newline&quot;</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.set/ind"></span><div class="section" id="clojure-set">
<h2>clojure.set<a class="headerlink" href="#clojure-set" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.set/difference"></span><div class="section" id="difference">
<h3>difference<a class="headerlink" href="#difference" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(difference s1)</strong></div>
<div class="line"><strong>(difference s1 s2)</strong></div>
<div class="line"><strong>(difference s1 s2 &amp; sets)</strong></div>
</div>
<p>返回集合 <code class="docutils literal"><span class="pre">s1</span></code> 和其余给定集合之间的差。</p>
<p>当只有一个参数时，返回该参数。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L48">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.set</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="c1">; 单个集合</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">difference </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">})</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:b</span><span class="p">}</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">s</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">}]</span> <span class="p">(</span><span class="nb">identical? </span><span class="nv">s</span> <span class="p">(</span><span class="nb">difference </span><span class="nv">s</span><span class="p">)))</span>
<span class="nv">true</span>

<span class="c1">; 两个集合</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">difference </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">})</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:c</span><span class="p">}</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">difference </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">})</span>
<span class="o">#</span><span class="p">{}</span>

<span class="c1">; 多个集合</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">difference </span><span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:b</span><span class="p">})</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:c</span><span class="p">}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/index"></span><div class="section" id="index">
<h3>index<a class="headerlink" href="#index" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(index xrel ks)</strong></div>
</div>
<p><code class="docutils literal"><span class="pre">index</span></code> 类似于 SQL 中的 <code class="docutils literal"><span class="pre">group</span> <span class="pre">by</span></code> 操作：它把 <code class="docutils literal"><span class="pre">xrel</span></code> 中的成员按 <code class="docutils literal"><span class="pre">ks</span></code> 中列举的 <code class="docutils literal"><span class="pre">key</span></code> 的值进行分组。</p>
<p>其中， <code class="docutils literal"><span class="pre">xrel</span></code> 和 <code class="docutils literal"><span class="pre">ks</span></code> 都是序列(sequence)。 <code class="docutils literal"><span class="pre">xrel</span></code> 的成员是一个个 <code class="docutils literal"><span class="pre">map</span></code> ， <code class="docutils literal"><span class="pre">ks</span></code> 的成员是用于分组的 <code class="docutils literal"><span class="pre">key</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">index</span></code> 返回一个新 <code class="docutils literal"><span class="pre">map</span></code> ，新 <code class="docutils literal"><span class="pre">map</span></code> 的 <code class="docutils literal"><span class="pre">key</span></code> 是 <code class="docutils literal"><span class="pre">ks</span></code> 的成员作为 <code class="docutils literal"><span class="pre">key</span></code> 在 <code class="docutils literal"><span class="pre">xrel</span></code> 中每个 <code class="docutils literal"><span class="pre">map</span></code> 取到的不同值，新 <code class="docutils literal"><span class="pre">map</span></code> 的 <code class="docutils literal"><span class="pre">value</span></code> 是满足这些值的 <code class="docutils literal"><span class="pre">xrel</span></code> 中成员的集合。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L95">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.set</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="c1">;; 处理 set</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">points</span> <span class="o">#</span><span class="p">{{</span><span class="ss">:x</span> <span class="mi">0</span> <span class="ss">:y</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span> <span class="ss">:y</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">0</span><span class="p">}})</span> <span class="c1">;; 定义三个点</span>
<span class="o">#</span><span class="ss">&#39;user/points</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">index </span><span class="nv">points</span> <span class="p">[</span><span class="ss">:x</span><span class="p">])</span>       <span class="c1">;; group by x 坐标</span>
<span class="p">{{</span><span class="ss">:x</span> <span class="mi">1</span><span class="p">}</span> <span class="o">#</span><span class="p">{{</span><span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:x</span> <span class="mi">1</span><span class="p">}}</span>,
 <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span><span class="p">}</span> <span class="o">#</span><span class="p">{{</span><span class="ss">:y</span> <span class="mi">1</span>, <span class="ss">:x</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:x</span> <span class="mi">0</span><span class="p">}}}</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">index </span><span class="nv">points</span> <span class="p">[</span><span class="ss">:y</span> <span class="ss">:x</span><span class="p">])</span>    <span class="c1">;; group by x 和 y 坐标</span>
<span class="p">{{</span><span class="ss">:x</span> <span class="mi">1</span>, <span class="ss">:y</span> <span class="mi">0</span><span class="p">}</span> <span class="o">#</span><span class="p">{{</span><span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:x</span> <span class="mi">1</span><span class="p">}}</span>,
 <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span>, <span class="ss">:y</span> <span class="mi">0</span><span class="p">}</span> <span class="o">#</span><span class="p">{{</span><span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:x</span> <span class="mi">0</span><span class="p">}}</span>,
 <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span>, <span class="ss">:y</span> <span class="mi">1</span><span class="p">}</span> <span class="o">#</span><span class="p">{{</span><span class="ss">:y</span> <span class="mi">1</span>, <span class="ss">:x</span> <span class="mi">0</span><span class="p">}}}</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">index </span><span class="nv">points</span> <span class="p">[</span><span class="ss">:z</span><span class="p">])</span>       <span class="c1">;; group by 不存在的 z 坐标</span>
<span class="p">{{}</span> <span class="o">#</span><span class="p">{{</span><span class="ss">:y</span> <span class="mi">1</span>, <span class="ss">:x</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:x</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:x</span> <span class="mi">1</span><span class="p">}}}</span>

<span class="c1">;; 还可以处理 vector</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">points-vec</span> <span class="p">[{</span><span class="ss">:x</span> <span class="mi">0</span> <span class="ss">:y</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span> <span class="ss">:y</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">0</span><span class="p">}])</span>
<span class="o">#</span><span class="ss">&#39;user/points-vec</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">index </span><span class="nv">points-vec</span> <span class="p">[</span><span class="ss">:x</span><span class="p">])</span>
<span class="p">{{</span><span class="ss">:x</span> <span class="mi">1</span><span class="p">}</span> <span class="o">#</span><span class="p">{{</span><span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:x</span> <span class="mi">1</span><span class="p">}}</span>, <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span><span class="p">}</span> <span class="o">#</span><span class="p">{{</span><span class="ss">:y</span> <span class="mi">1</span>, <span class="ss">:x</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:x</span> <span class="mi">0</span><span class="p">}}}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/intersection"></span><div class="section" id="intersection">
<h3>intersection<a class="headerlink" href="#intersection" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(intersection s1)</strong></div>
<div class="line"><strong>(intersection s1 s2)</strong></div>
<div class="line"><strong>(intersection s1 s2 &amp; sets)</strong></div>
</div>
<p>计算输入集合的交集。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L32">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.set</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">intersection </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">})</span>
<span class="o">#</span><span class="p">{</span><span class="mi">3</span><span class="p">}</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">intersection </span><span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="mi">2</span> <span class="mi">3</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="mi">3</span><span class="p">})</span>
<span class="o">#</span><span class="p">{</span><span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/join"></span><div class="section" id="join">
<h3>join<a class="headerlink" href="#join" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(join xrel yrel)</strong></div>
<div class="line"><strong>(join xrel yrel km)</strong></div>
</div>
<p><code class="docutils literal"><span class="pre">join</span></code> 类似于 SQL 中的 <code class="docutils literal"><span class="pre">join</span></code> 操作：它对 <code class="docutils literal"><span class="pre">xrel</span></code> 和 <code class="docutils literal"><span class="pre">yrel</span></code> 做关联操作。</p>
<p><code class="docutils literal"><span class="pre">xrel</span></code> 和 <code class="docutils literal"><span class="pre">yrel</span></code> 是两个序列，序列的每个成员都是一个 <code class="docutils literal"><span class="pre">map</span></code> ， <code class="docutils literal"><span class="pre">map</span></code> 的每个 key-value 对可以看做数据库表的字段以及对应的值。</p>
<p>如果提供了 <code class="docutils literal"><span class="pre">km</span></code> 参数，则按照 <code class="docutils literal"><span class="pre">km</span></code> 所列出的 <code class="docutils literal"><span class="pre">key</span></code> 进行关联。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L111">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.set</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="c1">;; 处理 set</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">students</span>             <span class="c1">;; 学生信息</span>
        <span class="o">#</span><span class="p">{{</span><span class="ss">:id</span> <span class="mi">1</span> <span class="ss">:name</span> <span class="s">&quot;Li Lei&quot;</span><span class="p">}</span>
          <span class="p">{</span><span class="ss">:id</span> <span class="mi">2</span> <span class="ss">:name</span> <span class="s">&quot;Han Meimei&quot;</span><span class="p">}})</span>
<span class="o">#</span><span class="ss">&#39;user/students</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">score</span>                <span class="c1">;; 学生成绩</span>
        <span class="o">#</span><span class="p">{{</span><span class="ss">:id</span> <span class="mi">1</span> <span class="ss">:score</span> <span class="mi">60</span><span class="p">}</span>
          <span class="p">{</span><span class="ss">:id</span> <span class="mi">2</span> <span class="ss">:score</span> <span class="mi">99</span><span class="p">}})</span>
<span class="o">#</span><span class="ss">&#39;user/score</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">join </span><span class="nv">students</span> <span class="nv">score</span><span class="p">)</span>     <span class="c1">;; 关联信息和成绩</span>
<span class="o">#</span><span class="p">{{</span><span class="ss">:score</span> <span class="mi">99</span>, <span class="ss">:name</span> <span class="s">&quot;Han Meimei&quot;</span>, <span class="ss">:id</span> <span class="mi">2</span><span class="p">}</span>
  <span class="p">{</span><span class="ss">:score</span> <span class="mi">60</span>, <span class="ss">:name</span> <span class="s">&quot;Li Lei&quot;</span>, <span class="ss">:id</span> <span class="mi">1</span><span class="p">}}</span>

<span class="c1">;; 处理 vector</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">score-vec</span>
         <span class="p">[{</span><span class="ss">:id</span> <span class="mi">1</span> <span class="ss">:score</span> <span class="mi">60</span><span class="p">}</span>
          <span class="p">{</span><span class="ss">:id</span> <span class="mi">2</span> <span class="ss">:score</span> <span class="mi">99</span><span class="p">}])</span>
<span class="o">#</span><span class="ss">&#39;user/score</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">join </span><span class="nv">students</span> <span class="nv">score-vec</span><span class="p">)</span>
<span class="o">#</span><span class="p">{{</span><span class="ss">:score</span> <span class="mi">99</span>, <span class="ss">:name</span> <span class="s">&quot;Han Meimei&quot;</span>, <span class="ss">:id</span> <span class="mi">2</span><span class="p">}</span>
  <span class="p">{</span><span class="ss">:score</span> <span class="mi">60</span>, <span class="ss">:name</span> <span class="s">&quot;Li Lei&quot;</span>, <span class="ss">:id</span> <span class="mi">1</span><span class="p">}}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/map-invert"></span><div class="section" id="map-invert">
<h3>map-invert<a class="headerlink" href="#map-invert" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(map-invert m)</strong></div>
</div>
<p>反转一个 <code class="docutils literal"><span class="pre">map</span></code> ，将它原本的 <code class="docutils literal"><span class="pre">value</span></code> 映射为新 <code class="docutils literal"><span class="pre">map</span></code> 的 <code class="docutils literal"><span class="pre">key</span></code> ，原本的 <code class="docutils literal"><span class="pre">key</span></code> 映射为新 <code class="docutils literal"><span class="pre">map</span></code> 的 <code class="docutils literal"><span class="pre">value</span></code> 。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">当多个 <code class="docutils literal"><span class="pre">key</span></code> 有同一个 <code class="docutils literal"><span class="pre">value</span></code> 时，新 <code class="docutils literal"><span class="pre">map</span></code> 只保留其中的一个作为 <code class="docutils literal"><span class="pre">key</span></code> 。</p>
</div>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L106">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.set</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">map-invert </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">})</span>
<span class="p">{</span><span class="mi">2</span> <span class="ss">:b</span>, <span class="mi">1</span> <span class="ss">:a</span><span class="p">}</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">map-invert </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">2</span><span class="p">})</span> <span class="c1">;; 两个 2 冲突，丢掉了 :c</span>
<span class="p">{</span><span class="mi">2</span> <span class="ss">:b</span>, <span class="mi">1</span> <span class="ss">:a</span><span class="p">}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/project"></span><div class="section" id="project">
<h3>project<a class="headerlink" href="#project" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(project xrel ks)</strong></div>
</div>
<p>对于 <code class="docutils literal"><span class="pre">xrel</span></code> 中的每个元素， <code class="docutils literal"><span class="pre">project</span></code> 的结果集合只包含那些 <code class="docutils literal"><span class="pre">key</span></code> 在 <code class="docutils literal"><span class="pre">ks</span></code> 里出现过的元素为成员。</p>
<p>换一种说法来讲就是：将 <code class="docutils literal"><span class="pre">xrel</span></code> 的成员投影到 <code class="docutils literal"><span class="pre">ks</span></code> 指定的维度上。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L71">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.set</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">points</span>           <span class="c1">;; 定义三个三维空间的点</span>
  <span class="o">#</span><span class="p">{{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">0</span> <span class="ss">:z</span> <span class="mi">1</span><span class="p">}</span>
    <span class="p">{</span><span class="ss">:x</span> <span class="mi">0</span> <span class="ss">:y</span> <span class="mi">1</span> <span class="ss">:z</span> <span class="mi">1</span><span class="p">}</span>
    <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span> <span class="ss">:y</span> <span class="mi">1</span> <span class="ss">:z</span> <span class="mi">0</span><span class="p">}})</span>
<span class="o">#</span><span class="ss">&#39;user/points</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">project </span><span class="nv">points</span> <span class="p">[</span><span class="ss">:x</span><span class="p">])</span> <span class="c1">;; 投影到 x 轴上</span>
<span class="o">#</span><span class="p">{{</span><span class="ss">:x</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="ss">:x</span> <span class="mi">1</span><span class="p">}}</span>            <span class="c1">;; 返回值是一个集合，所以计算结果中的两个 {:x 1} 只有一个被保留</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">project </span><span class="nv">points</span> <span class="p">[</span><span class="ss">:x</span> <span class="ss">:y</span><span class="p">])</span>
<span class="o">#</span><span class="p">{{</span><span class="ss">:y</span> <span class="mi">1</span>, <span class="ss">:x</span> <span class="mi">0</span><span class="p">}</span> <span class="p">{</span><span class="ss">:y</span> <span class="mi">1</span>, <span class="ss">:x</span> <span class="mi">1</span><span class="p">}</span> <span class="p">{</span><span class="ss">:y</span> <span class="mi">0</span>, <span class="ss">:x</span> <span class="mi">1</span><span class="p">}}</span> <span class="c1">;; 投影到 x-y 平面上</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/rename"></span><div class="section" id="rename">
<h3>rename<a class="headerlink" href="#rename" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(rename xrel kmap)</strong></div>
</div>
<p>把 <code class="docutils literal"><span class="pre">xrel</span></code> 中的元素的key改名，新旧名字的映射由 <code class="docutils literal"><span class="pre">kmap</span></code> 提供。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L89">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.set</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="k">def </span><span class="nv">students</span>
  <span class="o">#</span><span class="p">{{</span><span class="ss">:id</span> <span class="mi">1</span> <span class="ss">:name</span> <span class="s">&quot;Li Lei&quot;</span><span class="p">}</span>
    <span class="p">{</span><span class="ss">:id</span> <span class="mi">2</span> <span class="ss">:name</span> <span class="s">&quot;Han Meimei&quot;</span><span class="p">}})</span>
<span class="o">#</span><span class="ss">&#39;user/students</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">rename </span><span class="nv">students</span> <span class="p">{</span><span class="ss">:id</span> <span class="ss">:student-id</span><span class="p">})</span>
<span class="o">#</span><span class="p">{{</span><span class="ss">:name</span> <span class="s">&quot;Han Meimei&quot;</span>, <span class="ss">:student-id</span> <span class="mi">2</span><span class="p">}</span> <span class="p">{</span><span class="ss">:name</span> <span class="s">&quot;Li Lei&quot;</span>, <span class="ss">:student-id</span> <span class="mi">1</span><span class="p">}}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/rename-keys"></span><div class="section" id="rename-keys">
<h3>rename-keys<a class="headerlink" href="#rename-keys" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(rename-keys map kmap)</strong></div>
</div>
<p>把 <code class="docutils literal"><span class="pre">map</span></code> 中的 key 按照 <code class="docutils literal"><span class="pre">kmap</span></code> 提供的映射改名。</p>
<p>可以使用 <code class="docutils literal"><span class="pre">array-map</span></code> 类型的 <code class="docutils literal"><span class="pre">kmap</span></code> 来指定替换执行的顺序。</p>
<p>注意，替换可能造成 key 冲突，导致原来的 key-value 对被覆盖。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L77">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">rename-keys </span><span class="p">{</span><span class="ss">:id</span> <span class="mi">1</span> <span class="ss">:name</span> <span class="s">&quot;Li Lei&quot;</span><span class="p">}</span> <span class="p">{</span><span class="ss">:id</span> <span class="ss">:new-id</span> <span class="ss">:name</span> <span class="ss">:new-name</span><span class="p">})</span>
<span class="p">{</span><span class="ss">:new-id</span> <span class="mi">1</span>, <span class="ss">:new-name</span> <span class="s">&quot;Li Lei&quot;</span><span class="p">}</span>

<span class="c1">; 改名造成 key 冲突，旧的 {:b 2} 被覆盖</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">rename-keys </span><span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span><span class="p">}</span> <span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">})</span>
<span class="p">{</span><span class="ss">:b</span> <span class="mi">1</span><span class="p">}</span>

<span class="c1">; 通过 array-map 指定替换执行的顺序</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">rename-keys </span> <span class="p">{</span><span class="ss">:a</span> <span class="mi">1</span> <span class="ss">:b</span> <span class="mi">2</span> <span class="ss">:c</span> <span class="mi">3</span><span class="p">}</span>  <span class="p">(</span><span class="nb">array-map </span><span class="ss">:a</span> <span class="ss">:tmp</span> <span class="ss">:b</span> <span class="ss">:a</span> <span class="ss">:tmp</span> <span class="ss">:b</span><span class="p">))</span>
<span class="p">{</span><span class="ss">:b</span> <span class="mi">1</span>, <span class="ss">:a</span> <span class="mi">2</span>, <span class="ss">:c</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/select"></span><div class="section" id="select">
<h3>select<a class="headerlink" href="#select" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(select pred xset)</strong></div>
</div>
<p>返回 <code class="docutils literal"><span class="pre">xset</span></code> 中所有使 <code class="docutils literal"><span class="pre">pred</span></code> 为真的元素。</p>
<p><code class="docutils literal"><span class="pre">select</span></code> 和 <code class="docutils literal"><span class="pre">clojure.core/filter</span></code> 类似，只是 <code class="docutils literal"><span class="pre">select</span></code> 的输入和输出都是 <code class="docutils literal"><span class="pre">set</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L64">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.set</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">select </span><span class="nv">even?</span> <span class="o">#</span><span class="p">{</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">})</span>
<span class="o">#</span><span class="p">{</span><span class="mi">2</span> <span class="mi">4</span><span class="p">}</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">select </span><span class="nv">even?</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">])</span> <span class="c1">;; 只能是set</span>
<span class="nv">ClassCastException</span> <span class="nv">clojure.lang.PersistentVector</span> <span class="nv">cannot</span> <span class="nv">be</span> <span class="nb">cast </span><span class="nv">to</span> <span class="nv">clojure.lang.IPersistentSet</span>  <span class="nv">clojure.core/disj</span> <span class="p">(</span><span class="nf">core.clj</span><span class="ss">:1420</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/subset_q"></span><div class="section" id="subset">
<h3>subset?<a class="headerlink" href="#subset" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(subset? set1 set2)</strong></div>
</div>
<p>判断 <code class="docutils literal"><span class="pre">set1</span></code> 是否 <code class="docutils literal"><span class="pre">set2</span></code> 的子集。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L142">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/subset?</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">})</span>
<span class="nv">true</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/subset?</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:d</span><span class="p">})</span>
<span class="nv">false</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/subset?</span> <span class="o">#</span><span class="p">{}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:d</span><span class="p">})</span>
<span class="nv">true</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/subset?</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span><span class="p">})</span>
<span class="nv">true</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/superset_q"></span><div class="section" id="superset">
<h3>superset?<a class="headerlink" href="#superset" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(superset? set1 set2)</strong></div>
</div>
<p>判断 <code class="docutils literal"><span class="pre">set1</span></code> 是否 <code class="docutils literal"><span class="pre">set2</span></code> 的超集。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L150">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/superset?</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span> <span class="ss">:c</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">})</span>
<span class="nv">true</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/superset?</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:d</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">})</span>
<span class="nv">false</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/superset?</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">})</span>
<span class="nv">true</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/superset?</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">}</span> <span class="o">#</span><span class="p">{})</span>
<span class="nv">true</span>
</pre></div>
</div>
</div>
<span id="document-clojure.set/union"></span><div class="section" id="union">
<h3>union<a class="headerlink" href="#union" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(union)</strong></div>
<div class="line"><strong>(union s1)</strong></div>
<div class="line"><strong>(union s1 s2)</strong></div>
<div class="line"><strong>(union s1 s2 &amp; sets)</strong></div>
</div>
<p>返回输入集合的并集。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/5ca0c1feb7f7260aad257e52f2ddb0d426e2db77/src/clj/clojure/set.clj#L19">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/union</span><span class="p">)</span>
<span class="o">#</span><span class="p">{}</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/union</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:b</span> <span class="ss">:c</span><span class="p">})</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:b</span><span class="p">}</span>

<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">clojure.set/union</span> <span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:b</span><span class="p">}</span> <span class="o">#</span><span class="p">{</span><span class="ss">:b</span> <span class="ss">:c</span><span class="p">})</span>
<span class="o">#</span><span class="p">{</span><span class="ss">:a</span> <span class="ss">:c</span> <span class="ss">:b</span><span class="p">}</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.test/index"></span><div class="section" id="clojure-test">
<h2>clojure.test<a class="headerlink" href="#clojure-test" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.test/are"></span><div class="section" id="are">
<h3>are<a class="headerlink" href="#are" title="永久链接至标题">¶</a></h3>
<p>macro</p>
<div class="line-block">
<div class="line"><strong>(are argv expr &amp; args)</strong></div>
</div>
<p>通过以模板表达的方式检查多个断言(<code class="docutils literal"><span class="pre">assertions</span></code>)。关于模板的解释请查阅 <code class="docutils literal"><span class="pre">clojure.template/do-template</span></code></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="c1">;例子:</span>
<span class="p">(</span><span class="nf">are</span> <span class="p">[</span><span class="nv">x</span> <span class="nv">y</span><span class="p">]</span> <span class="p">(</span><span class="nb">= </span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
          <span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span>
          <span class="mi">4</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">2</span><span class="p">))</span>

<span class="c1">;宏将展开为:</span>
<span class="p">(</span><span class="k">do </span><span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">2</span> <span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">is</span> <span class="p">(</span><span class="nb">= </span><span class="mi">4</span> <span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">2</span><span class="p">))))</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.java.browse/index"></span><div class="section" id="clojure-java-browse">
<h2>clojure.java.browse<a class="headerlink" href="#clojure-java-browse" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.java.browse/browse-url"></span><div class="section" id="browse-url">
<h3>browse-url<a class="headerlink" href="#browse-url" title="永久链接至标题">¶</a></h3>
<p><strong>(browse-url url)</strong></p>
<p>在浏览器中打开地址 <code class="docutils literal"><span class="pre">url</span></code> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/b9b1a094499b69a94bd47fc94c4f082d80239fa9/src/clj/clojure/java/browse.clj#L46">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.browse</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">browse-url</span> <span class="s">&quot;http://clojuredocs.org&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.java.io/index"></span><div class="section" id="clojure-java-io">
<h2>clojure.java.io<a class="headerlink" href="#clojure-java-io" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.java.io/Coercions"></span><div class="section" id="coercions">
<h3>Coercions<a class="headerlink" href="#coercions" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">clojure.java.io</span></code> 内部定义的protocol，有 <code class="docutils literal"><span class="pre">as-file</span></code> 和 <code class="docutils literal"><span class="pre">as-url</span></code> 两个方法，clojure为多种类型实现了这个protocol。</p>
</div>
<span id="document-clojure.java.io/copy"></span><div class="section" id="copy">
<h3>copy<a class="headerlink" href="#copy" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(copy input output &amp; opts)</strong></div>
</div>
<p>把 <code class="docutils literal"><span class="pre">input</span></code> 的内容拷贝到 <code class="docutils literal"><span class="pre">output</span></code> ，成功返回 <code class="docutils literal"><span class="pre">nil</span></code> ，失败抛出 <code class="docutils literal"><span class="pre">IOException</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">input</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.InputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.Reader</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">byte</span></code> 数组，或者 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 。当输入是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 的时候，是把字符串本身拷贝到输出。</p>
<p><code class="docutils literal"><span class="pre">output</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.OutputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.Writer</span></code> 或者 <code class="docutils literal"><span class="pre">java.io.File</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">opts</span></code> 可以包含 <code class="docutils literal"><span class="pre">:buffer-size</span></code> 和 <code class="docutils literal"><span class="pre">encoding</span></code> 。 <code class="docutils literal"><span class="pre">:buffer-size</span></code> 默认1024。</p>
<p>除了自己打开的， <code class="docutils literal"><span class="pre">copy</span></code> 不会关闭任何流。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">copy</span> <span class="s">&quot;XXXXXX&quot;</span> <span class="p">(</span><span class="nf">output-stream</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">))</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span>
<span class="s">&quot;XXXXXX&quot;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">copy</span> <span class="p">(</span><span class="nf">file</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">output-stream</span> <span class="s">&quot;/tmp/xx&quot;</span><span class="p">))</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span>
<span class="s">&quot;XXXXXX&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/IOFactory"></span><div class="section" id="iofactory">
<h3>IOFactory<a class="headerlink" href="#iofactory" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">clojure.java.io</span></code> 内部定义的protocol，包含 <code class="docutils literal"><span class="pre">make-reader</span></code> ， <code class="docutils literal"><span class="pre">make-writer</span></code> ， <code class="docutils literal"><span class="pre">make-input-stream</span></code> 和 <code class="docutils literal"><span class="pre">make-out-stream</span></code> 四个方法。这四个方法创建的都是带缓冲区的reader，writer或stream。</p>
<p>用户应该避免直接使用上述四个API，而是使用 <code class="docutils literal"><span class="pre">reader</span></code> ， <code class="docutils literal"><span class="pre">writer</span></code> ， <code class="docutils literal"><span class="pre">input-stream</span></code> 和 <code class="docutils literal"><span class="pre">output-stream</span></code> 。</p>
</div>
<span id="document-clojure.java.io/input-stream"></span><div class="section" id="input-stream">
<h3>input-stream<a class="headerlink" href="#input-stream" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(input-stream x &amp; opts)</strong></div>
</div>
<p>根据 <code class="docutils literal"><span class="pre">x</span></code> 创建一个 <code class="docutils literal"><span class="pre">java.io.BufferedInputStream</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">x</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.InputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> ， <code class="docutils literal"><span class="pre">java.net.URI</span></code> ， <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.net.Socket</span></code> ， <code class="docutils literal"><span class="pre">byte</span></code> 数组或者 <code class="docutils literal"><span class="pre">char</span></code> 数组 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 时，会先尝试把 <code class="docutils literal"><span class="pre">x</span></code> 解释成 <code class="docutils literal"><span class="pre">java.net.URL</span></code> ，如果失败，则是 <code class="docutils literal"><span class="pre">java.io.File</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">opts</span></code> 定义创建选项，key可以是 <code class="docutils literal"><span class="pre">:append</span></code> 和 <code class="docutils literal"><span class="pre">:encoding</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">input-stream</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">))</span>
<span class="c1">;;#&lt;BufferedInputStream java.io.BufferedInputStream@21606a56&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">input-stream</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span> <span class="ss">:encoding</span> <span class="s">&quot;UTF-8&quot;</span><span class="p">)</span>
<span class="c1">;;#&lt;BufferedInputStream java.io.BufferedInputStream@3e347b11&gt;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/as-file"></span><div class="section" id="as-file">
<h3>as-file<a class="headerlink" href="#as-file" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(as-file x)</strong></div>
</div>
<p>接受一个 <code class="docutils literal"><span class="pre">x</span></code> 参数，返回一个 <code class="docutils literal"><span class="pre">java.io.File</span></code> 对象。 <code class="docutils literal"><span class="pre">x</span></code> 的类型可以是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> 和 <code class="docutils literal"><span class="pre">java.net.URI</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 的类型是 <code class="docutils literal"><span class="pre">java.net.URL</span></code> 和 <code class="docutils literal"><span class="pre">java.net.URI</span></code> 时，协议必须是 <code class="docutils literal"><span class="pre">file</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">nil</span></code> 时，返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">.exists</span> <span class="p">(</span><span class="nf">as-file</span> <span class="s">&quot;/tmp&quot;</span><span class="p">))</span>
<span class="nv">true</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">.exists</span> <span class="p">(</span><span class="nf">as-file</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;/tmp&quot;</span><span class="p">)))</span>
<span class="nv">true</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">.exists</span> <span class="p">(</span><span class="nf">as-file</span> <span class="p">(</span><span class="nf">java.net.URL.</span> <span class="s">&quot;file:///tmp&quot;</span><span class="p">)))</span>
<span class="nv">true</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">.exists</span> <span class="p">(</span><span class="nf">as-file</span> <span class="p">(</span><span class="nf">java.net.URL.</span> <span class="s">&quot;http://www.google.com&quot;</span><span class="p">)))</span>
<span class="c1">;;IllegalArgumentException Not a file: http://www.google.com  clojure.java.io/fn--8210 (io.clj:67)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/as-relative-path"></span><div class="section" id="as-relative-file">
<h3>as-relative-file<a class="headerlink" href="#as-relative-file" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(as-relative-path x)</strong></div>
</div>
<p>接受一个 <code class="docutils literal"><span class="pre">x</span></code> 参数，据此返回相对路径字符串。 <code class="docutils literal"><span class="pre">x</span></code> 的类型可以是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> 和 <code class="docutils literal"><span class="pre">java.net.URI</span></code> ，跟 <code class="docutils literal"><span class="pre">as-file</span></code> 一样。</p>
<p>如果 <code class="docutils literal"><span class="pre">x</span></code> 不是用相对路径表示的，则抛出 <code class="docutils literal"><span class="pre">IllegalArgumentException</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">as-relative-path</span> <span class="s">&quot;./tmp&quot;</span><span class="p">)</span>
<span class="s">&quot;./tmp&quot;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">as-relative-path</span> <span class="s">&quot;tmp&quot;</span><span class="p">)</span>
<span class="s">&quot;tmp&quot;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">as-relative-path</span> <span class="s">&quot;/tmp&quot;</span><span class="p">)</span>
<span class="c1">;;IllegalArgumentException /tmp is not a relative path  clojure.java.io/as-relative-path (io.clj:404)</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">as-relative-path</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;tmp-file&quot;</span><span class="p">))</span>
<span class="s">&quot;tmp-file&quot;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/as-url"></span><div class="section" id="as-url">
<h3>as-url<a class="headerlink" href="#as-url" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(as-url x)</strong></div>
</div>
<p>接受一个 <code class="docutils literal"><span class="pre">x</span></code> 参数，返回一个 <code class="docutils literal"><span class="pre">java.net.URL</span></code> 对象。 <code class="docutils literal"><span class="pre">x</span></code> 的类型可以是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> 和 <code class="docutils literal"><span class="pre">java.net.URI</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 的类型是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 时， <code class="docutils literal"><span class="pre">x</span></code> 必须是一个合法的URL。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">nil</span></code> 时，返回 <code class="docutils literal"><span class="pre">nil</span></code> 。</p>
<p>如果提供了 <code class="docutils literal"><span class="pre">km</span></code> 参数，则按照 <code class="docutils literal"><span class="pre">km</span></code> 所列出的key进行join。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">as-url</span> <span class="s">&quot;http://baidu.com&quot;</span><span class="p">)</span>
<span class="o">#</span><span class="nv">&lt;URL</span> <span class="nv">http</span><span class="ss">://baidu.com&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">as-url</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;/tmp&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="nv">&lt;URL</span> <span class="nv">file</span><span class="ss">:/tmp/&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">as-url</span> <span class="p">(</span><span class="nf">java.net.URI.</span> <span class="s">&quot;http://www.google.com&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="nv">&lt;URL</span> <span class="nv">http</span><span class="ss">://www.google.com&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">as-url</span> <span class="s">&quot;baidu.com&quot;</span><span class="p">)</span>
<span class="c1">;;MalformedURLException no protocol: baidu.com  java.net.URL.&lt;init&gt; (URL.java:567)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/default-streams-impl"></span><div class="section" id="default-streams-impl">
<h3>default-streams-impl<a class="headerlink" href="#default-streams-impl" title="永久链接至标题">¶</a></h3>
<p><code class="docutils literal"><span class="pre">IOFactory</span></code> 的默认实现，抛出 <code class="docutils literal"><span class="pre">IllegalArgumentException</span></code> 。</p>
</div>
<span id="document-clojure.java.io/delete-file"></span><div class="section" id="delete-file">
<h3>delete-file<a class="headerlink" href="#delete-file" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(delete-file f &amp; [silently])</strong></div>
</div>
<p>删除文件 <code class="docutils literal"><span class="pre">f</span></code> 。如果有第二个参数，且为真值，则当文件不存在的时候，不抛出异常。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">spit</span> <span class="s">&quot;/tmp/x&quot;</span> <span class="s">&quot;123&quot;</span><span class="p">)</span> <span class="c1">;; 创建一个文件，写入内容</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span> <span class="c1">;; 验证一下，已经存在</span>
<span class="s">&quot;123&quot;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">delete-file</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span> <span class="c1">;; 删掉它</span>
<span class="nv">true</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nb">slurp </span><span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span> <span class="c1">;; 没有了</span>
<span class="c1">;;FileNotFoundException /tmp/x (No such file or directory)  java.io.FileInputStream.open (FileInputStream.java:-2)</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">delete-file</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span> <span class="c1">;; 抛异常</span>
<span class="c1">;;IOException Couldn&#39;t delete /tmp/x  clojure.java.io/delete-file (io.clj:425)</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">delete-file</span> <span class="s">&quot;/tmp/x&quot;</span> <span class="nv">true</span><span class="p">)</span> <span class="c1">;; 安静删除</span>
<span class="nv">true</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/file"></span><div class="section" id="file">
<h3>file<a class="headerlink" href="#file" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(file arg)</strong></div>
<div class="line"><strong>(file parent child)</strong></div>
<div class="line"><strong>(file parent child &amp; more)</strong></div>
</div>
<p>根据参数创建一个 <code class="docutils literal"><span class="pre">java.io.File</span></code> 对象。</p>
<p>如果只有一个参数 <code class="docutils literal"><span class="pre">arg</span></code> ，返回对应的 <code class="docutils literal"><span class="pre">java.io.File</span></code> 对象。</p>
<p>如果有多个参数，第一个参数 <code class="docutils literal"><span class="pre">parent</span></code> 作为根目录；后续参数作为每一层子目录或文件，且必须是用相对路径表示的。</p>
<p><code class="docutils literal"><span class="pre">parent</span></code> , <code class="docutils literal"><span class="pre">child</span></code> 和 <code class="docutils literal"><span class="pre">more</span></code> 类型可以是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> 或者 <code class="docutils literal"><span class="pre">java.net.URI</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">file</span> <span class="s">&quot;/tmp&quot;</span><span class="p">)</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">file</span> <span class="s">&quot;/tmp&quot;</span> <span class="s">&quot;a&quot;</span> <span class="s">&quot;b&quot;</span><span class="p">)</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/a/b&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">file</span> <span class="s">&quot;/tmp&quot;</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;../b&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/a/../b&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">file</span> <span class="p">(</span><span class="nf">java.net.URL.</span> <span class="s">&quot;file:///tmp&quot;</span><span class="p">)</span> <span class="s">&quot;a&quot;</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;../b&quot;</span><span class="p">))</span>
<span class="o">#</span><span class="nv">&lt;File</span> <span class="nv">/tmp/a/../b&gt;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/make-input-stream"></span><div class="section" id="make-input-stream">
<h3>make-input-stream<a class="headerlink" href="#make-input-stream" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(make-input-stream x opts)</strong></div>
</div>
<p>根据 <code class="docutils literal"><span class="pre">x</span></code> 创建一个 <code class="docutils literal"><span class="pre">java.io.BufferedInputStream</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">x</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.BufferedInputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.InputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> ， <code class="docutils literal"><span class="pre">java.net.URI</span></code> ， <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.net.Socket</span></code> 或者 <code class="docutils literal"><span class="pre">byte</span></code> 数组。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 时，会先尝试把 <code class="docutils literal"><span class="pre">x</span></code> 解释成 <code class="docutils literal"><span class="pre">java.net.URL</span></code> ，如果失败，则是 <code class="docutils literal"><span class="pre">java.io.File</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">opt</span></code> 是一个map，定义选项，key可以是 <code class="docutils literal"><span class="pre">:append</span></code> 和 <code class="docutils literal"><span class="pre">:encoding</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">make-input-stream</span> <span class="s">&quot;/tmp/x&quot;</span> <span class="p">{})</span>
<span class="c1">;;#&lt;BufferedInputStream java.io.BufferedInputStream@3a7aa9f6&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">make-input-stream</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span> <span class="p">{})</span>
<span class="c1">;;#&lt;BufferedInputStream java.io.BufferedInputStream@df077d2&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">make-input-stream</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;/tmp/NO_SUCH_FILE&quot;</span><span class="p">)</span> <span class="p">{})</span>
<span class="c1">;;FileNotFoundException /tmp/NO_SUCH_FILE (No such file or directory)  java.io.FileInputStream.open (FileInputStream.java:-2)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/make-output-stream"></span><div class="section" id="make-output-stream">
<h3>make-output-stream<a class="headerlink" href="#make-output-stream" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(make-output-stream x opts)</strong></div>
</div>
<p>根据 <code class="docutils literal"><span class="pre">x</span></code> 创建 <code class="docutils literal"><span class="pre">java.io.BufferedOutputStream</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">x</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.BufferOutputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.OutputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> ， <code class="docutils literal"><span class="pre">java.net.URI</span></code> ， <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.net.Socket</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 时，会先尝试把 <code class="docutils literal"><span class="pre">x</span></code> 解释成 <code class="docutils literal"><span class="pre">java.net.URL</span></code> ，如果失败，则是 <code class="docutils literal"><span class="pre">java.io.File</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.net.URL</span></code> 和 <code class="docutils literal"><span class="pre">java.net.URI</span></code> 时，协议必须是 <code class="docutils literal"><span class="pre">file</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">opt</span></code> 是一个map，定义选项，key可以是 <code class="docutils literal"><span class="pre">:append</span></code> 和 <code class="docutils literal"><span class="pre">:encoding</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">make-output-stream</span> <span class="s">&quot;/tmp/x&quot;</span> <span class="p">{})</span>
<span class="c1">;;#&lt;BufferedOutputStream java.io.BufferedOutputStream@5440bf04&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">make-output-stream</span> <span class="p">(</span><span class="nf">file</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span> <span class="p">{})</span>
<span class="c1">;;#&lt;BufferedOutputStream java.io.BufferedOutputStream@4268d15&gt;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/make-parents"></span><div class="section" id="make-parents">
<h3>make-parents<a class="headerlink" href="#make-parents" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(make-parents f &amp; more)</strong></div>
</div>
<p>创建父目录，成功返回 <code class="docutils literal"><span class="pre">true</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">f</span></code> 和 <code class="docutils literal"><span class="pre">more</span></code> 可以是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> 或者 <code class="docutils literal"><span class="pre">java.net.URI</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">make-parents</span> <span class="s">&quot;/tmp/a/b/c/d&quot;</span><span class="p">)</span> <span class="c1">;; 创建 /tmp/a/b/c/</span>
<span class="nv">true</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">make-parents</span> <span class="s">&quot;/tmp/a/x/&quot;</span> <span class="s">&quot;y&quot;</span> <span class="s">&quot;z/&quot;</span><span class="p">)</span> <span class="c1">;; 创建 /tmp/a/x/y</span>
<span class="nv">true</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/make-reader"></span><div class="section" id="make-reader">
<h3>make-reader<a class="headerlink" href="#make-reader" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(make-reader x opts)</strong></div>
</div>
<p>根据 <code class="docutils literal"><span class="pre">x</span></code> 创建一个 <code class="docutils literal"><span class="pre">java.io.BufferedReader</span></code> 。<code class="docutils literal"><span class="pre">x</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.InputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> ， <code class="docutils literal"><span class="pre">java.net.URI</span></code> ， <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.net.Socket</span></code> ， <code class="docutils literal"><span class="pre">byte</span></code> 数组或者 <code class="docutils literal"><span class="pre">char</span></code> 数组 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 时，会先尝试把 <code class="docutils literal"><span class="pre">x</span></code> 解释成 <code class="docutils literal"><span class="pre">java.net.URL</span></code> ，如果失败，则是 <code class="docutils literal"><span class="pre">java.io.File</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">opt</span></code> 是一个map，定义选项，key可以是 <code class="docutils literal"><span class="pre">:append</span></code> 和 <code class="docutils literal"><span class="pre">:encoding</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">make-reader</span> <span class="s">&quot;http://baidu.com&quot;</span> <span class="p">{})</span>
<span class="c1">;;#&lt;BufferedReader java.io.BufferedReader@5994a1e9&gt;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/make-writer"></span><div class="section" id="make-writer">
<h3>make-writer<a class="headerlink" href="#make-writer" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(make-writer x opts)</strong></div>
</div>
<p>跟据 <code class="docutils literal"><span class="pre">x</span></code> 构造 <code class="docutils literal"><span class="pre">java.io.BufferedWriter</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">x</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.BufferOutputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.OutputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> ， <code class="docutils literal"><span class="pre">java.net.URI</span></code> ， <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.net.Socket</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 时，会先尝试把 <code class="docutils literal"><span class="pre">x</span></code> 解释成 <code class="docutils literal"><span class="pre">java.net.URL</span></code> ，如果失败，则是 <code class="docutils literal"><span class="pre">java.io.File</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.net.URL</span></code> 和 <code class="docutils literal"><span class="pre">java.net.URI</span></code> 时，协议必须是 <code class="docutils literal"><span class="pre">file</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">opt</span></code> 是一个map，定义选项，key可以是 <code class="docutils literal"><span class="pre">:append</span></code> 和 <code class="docutils literal"><span class="pre">:encoding</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">make-writer</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="s">&quot;/tmp/xxx&quot;</span><span class="p">)</span> <span class="p">{})</span>
<span class="c1">;;#&lt;BufferedWriter java.io.BufferedWriter@c92fa70&gt;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/output-stream"></span><div class="section" id="output-stream">
<h3>output-stream<a class="headerlink" href="#output-stream" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(output-stream x &amp; opts)</strong></div>
</div>
<p>根据 <code class="docutils literal"><span class="pre">x</span></code> 创建 <code class="docutils literal"><span class="pre">java.io.BufferedOutputStream</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">x</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.BufferOutputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.OutputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> ， <code class="docutils literal"><span class="pre">java.net.URI</span></code> ， <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.net.Socket</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 时，会先尝试把 <code class="docutils literal"><span class="pre">x</span></code> 解释成 <code class="docutils literal"><span class="pre">java.net.URL</span></code> ，如果失败，则是 <code class="docutils literal"><span class="pre">java.io.File</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.net.URL</span></code> 和 <code class="docutils literal"><span class="pre">java.net.URI</span></code> 时，协议必须是 <code class="docutils literal"><span class="pre">file</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">opt</span></code> 定义创建选项，key可以是 <code class="docutils literal"><span class="pre">:append</span></code> 和 <code class="docutils literal"><span class="pre">:encoding</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">input-stream</span> <span class="p">(</span><span class="nf">as-file</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">))</span>
<span class="c1">;;#&lt;BufferedInputStream java.io.BufferedInputStream@49160709&gt;</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">input-stream</span> <span class="p">(</span><span class="nf">as-file</span> <span class="s">&quot;/tmp/x&quot;</span><span class="p">)</span> <span class="ss">:append</span> <span class="nv">true</span><span class="p">)</span>
<span class="c1">;;#&lt;BufferedInputStream java.io.BufferedInputStream@7f6ce64e&gt;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/reader"></span><div class="section" id="reader">
<h3>reader<a class="headerlink" href="#reader" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(reader x &amp; opts)</strong></div>
</div>
<p>根据 <code class="docutils literal"><span class="pre">x</span></code> 创建一个 <code class="docutils literal"><span class="pre">java.io.BufferedReader</span></code> 。<code class="docutils literal"><span class="pre">x</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.InputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> ， <code class="docutils literal"><span class="pre">java.net.URI</span></code> ， <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.net.Socket</span></code> ， <code class="docutils literal"><span class="pre">byte</span></code> 数组或者 <code class="docutils literal"><span class="pre">char</span></code> 数组 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 时，会先尝试把 <code class="docutils literal"><span class="pre">x</span></code> 解释成 <code class="docutils literal"><span class="pre">java.net.URL</span></code> ，如果失败，则是 <code class="docutils literal"><span class="pre">java.io.File</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">opt</span></code> 是一个map，定义选项，key可以是 <code class="docutils literal"><span class="pre">:append</span></code> 和 <code class="docutils literal"><span class="pre">:encoding</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">reader</span> <span class="s">&quot;http://baidu.com&quot;</span> <span class="ss">:encoding</span> <span class="s">&quot;GB2312&quot;</span><span class="p">)</span>
<span class="c1">;;#&lt;BufferedReader java.io.BufferedReader@620a9239&gt;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/resource"></span><div class="section" id="resource">
<h3>resource<a class="headerlink" href="#resource" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(resource n)</strong></div>
<div class="line"><strong>(resource n loader)</strong></div>
</div>
<p>是用 <code class="docutils literal"><span class="pre">ClassLoader</span></code> 加载资源文件，返回 <code class="docutils literal"><span class="pre">java.net.URL</span></code> 对象。如果找不到资源文件，返回 <code class="docutils literal"><span class="pre">nil</span></code>。</p>
<p><code class="docutils literal"><span class="pre">n</span></code> 是资源名字字符串。 如果要使用特定的 <code class="docutils literal"><span class="pre">ClassLoader</span></code> ，需要使用 <code class="docutils literal"><span class="pre">loader</span></code> 参数。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">resource</span> <span class="s">&quot;project.clj&quot;</span><span class="p">)</span>
<span class="o">#</span><span class="nv">&lt;URL</span> <span class="nv">jar</span><span class="ss">:file:/Users/xiafei/.lein/self-installs/leiningen-2.0.0-preview10-standalone.jar!/project.clj&gt;</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.io/writer"></span><div class="section" id="writer">
<h3>writer<a class="headerlink" href="#writer" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(writer x &amp; opts)</strong></div>
</div>
<p>跟据 <code class="docutils literal"><span class="pre">x</span></code> 构造 <code class="docutils literal"><span class="pre">java.io.BufferedWriter</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">x</span></code> 可以是 <code class="docutils literal"><span class="pre">java.io.BufferOutputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.OutputStream</span></code> ， <code class="docutils literal"><span class="pre">java.io.File</span></code> ， <code class="docutils literal"><span class="pre">java.net.URL</span></code> ， <code class="docutils literal"><span class="pre">java.net.URI</span></code> ， <code class="docutils literal"><span class="pre">java.lang.String</span></code> ， <code class="docutils literal"><span class="pre">java.net.Socket</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.lang.String</span></code> 时，会先尝试把 <code class="docutils literal"><span class="pre">x</span></code> 解释成 <code class="docutils literal"><span class="pre">java.net.URL</span></code> ，如果失败，则是 <code class="docutils literal"><span class="pre">java.io.File</span></code> 。</p>
<p>当 <code class="docutils literal"><span class="pre">x</span></code> 是 <code class="docutils literal"><span class="pre">java.net.URL</span></code> 和 <code class="docutils literal"><span class="pre">java.net.URI</span></code> 时，协议必须是 <code class="docutils literal"><span class="pre">file</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">opt</span></code> 是一个map，定义选项，key可以是 <code class="docutils literal"><span class="pre">:append</span></code> 和 <code class="docutils literal"><span class="pre">:encoding</span></code> 。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.io</span><span class="p">)</span>
<span class="nv">nil</span>
<span class="nv">user&gt;</span> <span class="p">(</span><span class="nf">writer</span> <span class="p">(</span><span class="nf">java.net.URL.</span> <span class="s">&quot;file:///tmp/x&quot;</span><span class="p">)</span> <span class="ss">:append</span> <span class="nv">true</span><span class="p">)</span>
<span class="c1">;;#&lt;BufferedWriter java.io.BufferedWriter@7274187a&gt;</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.java.javadoc/index"></span><div class="section" id="clojure-java-javadoc">
<h2>clojure.java.javadoc<a class="headerlink" href="#clojure-java-javadoc" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.java.javadoc/add-local-javadoc"></span><div class="section" id="add-local-javadoc">
<h3>add-local-javadoc<a class="headerlink" href="#add-local-javadoc" title="永久链接至标题">¶</a></h3>
<p><strong>(add-local-javadoc path)</strong></p>
<p>将路径 <code class="docutils literal"><span class="pre">path</span></code> 添加到本地 javadoc 的路径列表中。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/be9ff491c4b2c23790fb316804551768960e355d/src/clj/clojure/java/javadoc.clj#L39">查看源码</a></p>
</div>
<span id="document-clojure.java.javadoc/add-remote-javadoc"></span><div class="section" id="add-remote-javadoc">
<h3>add-remote-javadoc<a class="headerlink" href="#add-remote-javadoc" title="永久链接至标题">¶</a></h3>
<p><strong>(add-remote-javadoc package-prefix url)</strong></p>
<p>添加路径 <code class="docutils literal"><span class="pre">url</span></code> 到远程 javadoc 路径的列表， <code class="docutils literal"><span class="pre">package-prefix</span></code> 是 URL 对应的 javadoc 的包名的开始部分。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/be9ff491c4b2c23790fb316804551768960e355d/src/clj/clojure/java/javadoc.clj#L45">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.javadoc</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">add-remote-javadoc</span> <span class="s">&quot;org.apache.commons.csv.&quot;</span> <span class="s">&quot;http://commons.apache.org/proper/commons-csv/apidocs/index.html&quot;</span><span class="p">)</span>
<span class="p">{</span><span class="s">&quot;java.&quot;</span> <span class="s">&quot;http://java.sun.com/javase/6/docs/api/&quot;</span>, <span class="s">&quot;javax.&quot;</span> <span class="s">&quot;http://java.sun.com/javase/6/docs/api/&quot;</span>, <span class="s">&quot;org.apache.commons.codec.&quot;</span> <span class="s">&quot;http://commons.apache.org/codec/api-release/&quot;</span>, <span class="s">&quot;org.apache.commons.csv.&quot;</span> <span class="s">&quot;http://commons.apache.org/proper/commons-csv/apidocs/index.html&quot;</span>, <span class="s">&quot;org.apache.commons.io.&quot;</span> <span class="s">&quot;http://commons.apache.org/io/api-release/&quot;</span>, <span class="s">&quot;org.apache.commons.lang.&quot;</span> <span class="s">&quot;http://commons.apache.org/lang/api-release/&quot;</span>, <span class="s">&quot;org.ietf.jgss.&quot;</span> <span class="s">&quot;http://java.sun.com/javase/6/docs/api/&quot;</span>, <span class="s">&quot;org.omg.&quot;</span> <span class="s">&quot;http://java.sun.com/javase/6/docs/api/&quot;</span>, <span class="s">&quot;org.w3c.dom.&quot;</span> <span class="s">&quot;http://java.sun.com/javase/6/docs/api/&quot;</span>, <span class="s">&quot;org.xml.sax.&quot;</span> <span class="s">&quot;http://java.sun.com/javase/6/docs/api/&quot;</span><span class="p">}</span>
</pre></div>
</div>
</div>
<span id="document-clojure.java.javadoc/javadoc"></span><div class="section" id="javadoc">
<h3>javadoc<a class="headerlink" href="#javadoc" title="永久链接至标题">¶</a></h3>
<p><strong>(javadoc class-or-object)</strong></p>
<p>使用阅览器打开 <code class="docutils literal"><span class="pre">class-or-object</span></code> 参数的相关 javadoc 文档。</p>
<p>优先打开本地文档（ <code class="docutils literal"><span class="pre">*local-javadocs*</span></code> ），
其次才是远程文档（ <code class="docutils literal"><span class="pre">*remote-javadoc*</span></code> ）。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/be9ff491c4b2c23790fb316804551768960e355d/src/clj/clojure/java/javadoc.clj#L73">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">use</span> <span class="ss">&#39;clojure.java.javadoc</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">javadoc</span> <span class="nv">String</span><span class="p">)</span>
<span class="s">&quot;http://java.sun.com/javase/6/docs/api/java/lang/String.html&quot;</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">javadoc</span> <span class="p">(</span><span class="nf">java.util.Date.</span><span class="p">))</span>
<span class="s">&quot;http://java.sun.com/javase/6/docs/api/java/util/Date.html&quot;</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.java.shell/index"></span><div class="section" id="clojure-java-shell">
<h2>clojure.java.shell<a class="headerlink" href="#clojure-java-shell" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.java.shell/sh"></span><div class="section" id="sh">
<span id="id1"></span><h3>sh<a class="headerlink" href="#sh" title="永久链接至标题">¶</a></h3>
<p><strong>(sh &amp; args)</strong></p>
<p>传递给出的字符串到 <code class="docutils literal"><span class="pre">Runtime.exec()</span></code> 来启动一个子进程。</p>
<p>选项有：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">:in</span></code> ：给出下列合法的输入源给 <code class="docutils literal"><span class="pre">clojure.java.io/copy</span></code> , 比如， <code class="docutils literal"><span class="pre">InputStream</span></code> , <code class="docutils literal"><span class="pre">Reader</span></code> , <code class="docutils literal"><span class="pre">File</span></code> , <code class="docutils literal"><span class="pre">byte[]</span></code> 或者 <code class="docutils literal"><span class="pre">String</span></code> , 来提供子进程的标准输入（stdin）。</li>
<li><code class="docutils literal"><span class="pre">:in-enc</span></code> ：给出一个字符串。作为字符的编码名（比如， <code class="docutils literal"><span class="pre">UTF-8</span></code> 或者 <code class="docutils literal"><span class="pre">ISO-8859-1</span></code>）来转换 <code class="docutils literal"><span class="pre">:in</span></code> 中给定的字符串的编码，默认是 <code class="docutils literal"><span class="pre">UTF-8</span></code> 。 如果 <code class="docutils literal"><span class="pre">:in</span></code> 给出的字节数组(byte array), 那么它不会被解码，这个选项会被忽略。</li>
<li><code class="docutils literal"><span class="pre">:out-enc</span></code> ：选项可以是一个 <code class="docutils literal"><span class="pre">:bytes</span></code> 或者一个 <code class="docutils literal"><span class="pre">String</span></code> ， 如果给出的是一个 <code class="docutils literal"><span class="pre">String</span></code> , 它会被当作一个字符编码的名字，（比如， <code class="docutils literal"><span class="pre">UTF-8</span></code> 或者 <code class="docutils literal"><span class="pre">ISO-8859-1</span></code>）来转换子进程的标准输出的字符串编码，如果给出的是 <code class="docutils literal"><span class="pre">:bytes</span></code> , 子进程的标准输出会被存储到一个字节数组返回，默认是 <code class="docutils literal"><span class="pre">UTF-8</span></code> 。</li>
<li><code class="docutils literal"><span class="pre">:env</span></code> ：用一个 map 重载进程的环境变量（env），如果你是一个受虐狂，你可以用一个 <code class="docutils literal"><span class="pre">String[]</span></code> 。</li>
<li><code class="docutils literal"><span class="pre">:dir</span></code> ：用一个 <code class="docutils literal"><span class="pre">String</span></code>  或者  <code class="docutils literal"><span class="pre">java.io.File</span></code>  重载进程工作目录（dir）</li>
</ul>
<p>你可以用 <code class="docutils literal"><span class="pre">with-sh-env</span></code> 或者 <code class="docutils literal"><span class="pre">with-sh-dir</span></code> 绑定 <code class="docutils literal"><span class="pre">:env</span></code> 或者 <code class="docutils literal"><span class="pre">:dir</span></code> 到多个操作。</p>
<p><code class="docutils literal"><span class="pre">sh</span></code> 返回一个 map ：</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">:exit</span></code> ：子进程的返回码</li>
<li><code class="docutils literal"><span class="pre">:out</span></code> ：子进程的标准输出（stdout）（<code class="docutils literal"><span class="pre">byte[]</span></code> 或者 <code class="docutils literal"><span class="pre">String</span></code>）</li>
<li><code class="docutils literal"><span class="pre">:err</span></code> ：子进程的标准错误（stderr）（用平台默认的编码的 <code class="docutils literal"><span class="pre">String</span></code>）</li>
</ul>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/fe0cfc71e6ec7b546066188c555b01dae0e368e8/src/clj/clojure/java/shell.clj#L79">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre>user=&gt; (use &#39;[clojure.java.shell :only [sh]])

;; Note: The actual output you see from a command like this will look messier.
;; The output below has had all newline characters replaced with line
;; breaks.  You would see a big long string with \n characters in the middle.
user=&gt; (sh &quot;ls&quot; &quot;-aul&quot;)

{:exit 0,
 :out &quot;total 64
drwxr-xr-x  11 zkim  staff    374 Jul  5 13:21 .
drwxr-xr-x  25 zkim  staff    850 Jul  5 13:02 ..
drwxr-xr-x  12 zkim  staff    408 Jul  5 13:02 .git
-rw-r--r--   1 zkim  staff     13 Jul  5 13:02 .gitignore
-rw-r--r--   1 zkim  staff  12638 Jul  5 13:02 LICENSE.html
-rw-r--r--   1 zkim  staff   4092 Jul  5 13:02 README.md
drwxr-xr-x   2 zkim  staff     68 Jul  5 13:15 classes
drwxr-xr-x   5 zkim  staff    170 Jul  5 13:15 lib
-rw-r--r--@  1 zkim  staff   3396 Jul  5 13:03 pom.xml
-rw-r--r--@  1 zkim  staff    367 Jul  5 13:15 project.clj
drwxr-xr-x   4 zkim  staff    136 Jul  5 13:15 src
&quot;, :err &quot;&quot;}


user=&gt; (use &#39;[clojure.java.shell :only [sh]])

user=&gt; (println (:out (sh &quot;cowsay&quot; &quot;Printing a command-line output&quot;)))

 _________________________________
&lt; Printing a command-line output. &gt;
 ---------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||

nil




user=&gt; (use &#39;[clojure.java.shell :only [sh]])
nil

;; note that the options, like :in, have to go at the end of arglist
;; advantage of piping-in thru stdin is less need for quoting/escaping
user=&gt; (println (:out (sh &quot;cat&quot; &quot;-&quot; :in &quot;Printing input from stdin with funny chars like &#39; \&quot; $@ &amp; &quot;)))
Printing input from stdin with funny chars like &#39; &quot; $@ &amp;
nil
</pre></div>
</div>
</div>
<span id="document-clojure.java.shell/with-sh-dir"></span><div class="section" id="with-sh-dir">
<h3>with-sh-dir<a class="headerlink" href="#with-sh-dir" title="永久链接至标题">¶</a></h3>
<p><strong>(with-sh-dir dir &amp; forms)</strong></p>
<p>设置 <code class="docutils literal"><span class="pre">sh</span></code> 函数所使用的目录，
详情请参见 <a class="reference internal" href="index.html#sh"><span>sh 函数的文档</span></a> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/fe0cfc71e6ec7b546066188c555b01dae0e368e8/src/clj/clojure/java/shell.clj#L21">查看源码</a></p>
</div>
<span id="document-clojure.java.shell/with-sh-env"></span><div class="section" id="with-sh-env">
<h3>with-sh-env<a class="headerlink" href="#with-sh-env" title="永久链接至标题">¶</a></h3>
<p><strong>(with-sh-env env &amp; forms)</strong></p>
<p>设置 <code class="docutils literal"><span class="pre">sh</span></code> 函数所使用的环境变量，
详情请参见 <a class="reference internal" href="index.html#sh"><span>sh 函数的文档</span></a> 。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/fe0cfc71e6ec7b546066188c555b01dae0e368e8/src/clj/clojure/java/shell.clj#L28">查看源码</a></p>
</div>
</div>
</div>
<span id="document-clojure.xml/index"></span><div class="section" id="clojure-xml">
<h2>clojure.xml<a class="headerlink" href="#clojure-xml" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.xml/parse"></span><div class="section" id="parse">
<h3>parse<a class="headerlink" href="#parse" title="永久链接至标题">¶</a></h3>
<p><strong>(parse s)</strong></p>
<p><strong>(parse s startparse)</strong></p>
<p>解析并加载源 <code class="docutils literal"><span class="pre">s</span></code> ， <code class="docutils literal"><span class="pre">s</span></code> 可以是一个文件， <code class="docutils literal"><span class="pre">InputStream</span></code> ,或者一个代表 URL 的字符串。</p>
<p>函数返回一棵 <code class="docutils literal"><span class="pre">xml/element</span></code> 类型的 <code class="docutils literal"><span class="pre">struct-map</span></code> 树，
<code class="docutils literal"><span class="pre">struct-map</span></code> 中包含键 <code class="docutils literal"><span class="pre">:tag</span></code> 、 <code class="docutils literal"><span class="pre">:attrs</span></code> 、 <code class="docutils literal"><span class="pre">:content</span></code> ，
以及访问函数 <code class="docutils literal"><span class="pre">tag</span></code> 、 <code class="docutils literal"><span class="pre">attrs</span></code> 、 <code class="docutils literal"><span class="pre">content</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">startparse</span></code> 用于指定解释所使用的解释器，
这个参数的值应该是一个函数：
函数接受一个源（source）和一个内容处理器（ContentHandler）作为参数，
并返回一个解释器作为函数的返回值。</p>
<p><a class="reference external" href="https://github.com/clojure/clojure/blob/b9b1a094499b69a94bd47fc94c4f082d80239fa9/src/clj/clojure/xml.clj#L78">查看源码</a></p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="p">(</span><span class="nf">require</span> <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.xml</span> <span class="ss">:as</span> <span class="nv">xml</span><span class="p">]</span>
 <span class="o">&#39;</span><span class="p">[</span><span class="nv">clojure.zip</span> <span class="ss">:as</span> <span class="nv">zip</span><span class="p">])</span>

<span class="c1">;;convenience function, first sawn at nakkaya.com later in clj.zip src</span>
<span class="p">(</span><span class="kd">defn </span><span class="nv">zip-str</span> <span class="p">[</span><span class="nv">s</span><span class="p">]</span>
  <span class="p">(</span><span class="nf">zip/xml-zip</span> <span class="p">(</span><span class="nf">xml/parse</span> <span class="p">(</span><span class="nf">java.io.ByteArrayInputStream.</span> <span class="p">(</span><span class="nf">.getBytes</span> <span class="nv">s</span><span class="p">)))))</span>

<span class="c1">;;parse from xml-strings to internal xml representation</span>
<span class="p">(</span><span class="nf">zip-str</span> <span class="s">&quot;&lt;a href=&#39;nakkaya.com&#39;/&gt;&quot;</span><span class="p">)</span>
<span class="nv">=&gt;</span>
<span class="p">[{</span><span class="ss">:tag</span> <span class="ss">:a</span>, <span class="ss">:attrs</span> <span class="p">{</span><span class="ss">:href</span> <span class="s">&quot;nakkaya.com&quot;</span><span class="p">}</span>, <span class="ss">:content</span> <span class="nv">nil</span><span class="p">}</span> <span class="nv">nil</span><span class="p">]</span>

<span class="c1">;;root can be rendered with xml/emit-element</span>
<span class="p">(</span><span class="nf">xml/emit-element</span> <span class="p">(</span><span class="nf">zip/root</span> <span class="p">[{</span><span class="ss">:tag</span> <span class="ss">:a</span>, <span class="ss">:attrs</span> <span class="p">{</span><span class="ss">:href</span> <span class="s">&quot;nakkaya.com&quot;</span><span class="p">}</span>, <span class="ss">:content</span> <span class="nv">nil</span><span class="p">}</span> <span class="nv">nil</span><span class="p">]))</span>
<span class="nv">=&gt;</span>
<span class="nv">&lt;a</span> <span class="nv">href=</span><span class="ss">&#39;nakkaya.com&#39;/&gt;</span>
<span class="c1">;;printed (to assure it&#39;s not lazy and performance), can be catched to string variable with with-out-str</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-clojure.repl/index"></span><div class="section" id="clojure-repl">
<h2>clojure.repl<a class="headerlink" href="#clojure-repl" title="永久链接至标题">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-clojure.repl/apropos"></span><div class="section" id="apropos">
<h3>apropos<a class="headerlink" href="#apropos" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(apropos str-or-pattern)</strong></div>
</div>
<p>返回当前命名空间下所有与给定正则表达式或者字符串(str-or-pattern)相匹配的定义的序列</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">apropos</span> <span class="s">&quot;temp&quot;</span><span class="p">)</span>
<span class="p">()</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;clojure.template</span><span class="p">)</span>
<span class="nv">nil</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">apropos</span> <span class="s">&quot;temp&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">apply-template</span> <span class="nv">do-template</span><span class="p">)</span>

<span class="c1">;; 使用正则表达式</span>
<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">apropos</span> <span class="o">#</span><span class="s">&quot;.*-temp*&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="nf">apply-template</span> <span class="nv">do-template</span><span class="p">)</span>
</pre></div>
</div>
</div>
<span id="document-clojure.repl/dir"></span><div class="section" id="dir">
<h3>dir<a class="headerlink" href="#dir" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(dir nsname)</strong></div>
</div>
<p>分类打印出给定命名空间下的公共Var对象</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;clojure.string</span> <span class="ss">&#39;clojure.repl</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">clojure.repl/dir</span> <span class="nv">clojure.string</span><span class="p">)</span>
<span class="nv">blank?</span>
<span class="nv">capitalize</span>
<span class="nv">escape</span>
<span class="nv">join</span>
<span class="nv">lower-case</span>
<span class="nv">replace</span>
<span class="nv">replace-first</span>
<span class="nv">reverse</span>
<span class="nv">split</span>
<span class="nv">split-lines</span>
<span class="nv">trim</span>
<span class="nv">trim-newline</span>
<span class="nv">triml</span>
<span class="nv">trimr</span>
<span class="nv">upper-case</span>
</pre></div>
</div>
</div>
<span id="document-clojure.repl/dir-fn"></span><div class="section" id="dir-fn">
<h3>dir-fn<a class="headerlink" href="#dir-fn" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(dir-fn ns)</strong></div>
</div>
<p>返回一个有序序列，该序列包括给定命名空间(ns)的公共Var对象。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;clojure.repl</span> <span class="ss">&#39;clojure.string</span><span class="p">)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pprint</span> <span class="p">(</span><span class="nf">clojure.repl/dir-fn</span> <span class="ss">&#39;clojure.string</span><span class="p">))</span>
<span class="p">(</span><span class="nf">blank?</span>
 <span class="nv">capitalize</span>
 <span class="nv">escape</span>
 <span class="nv">join</span>
 <span class="nv">lower-case</span>
 <span class="nv">replace</span>
 <span class="nv">replace-first</span>
 <span class="nv">reverse</span>
 <span class="nv">split</span>
 <span class="nv">split-lines</span>
 <span class="nv">trim</span>
 <span class="nv">trim-newline</span>
 <span class="nv">triml</span>
 <span class="nv">trimr</span>
 <span class="nv">upper-case</span><span class="p">)</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
<span id="document-clojure.repl/doc"></span><div class="section" id="doc">
<h3>doc<a class="headerlink" href="#doc" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(doc name)</strong></div>
</div>
<p>打印出某个Var对象或者special form的文档信息</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">doc </span><span class="nv">map</span><span class="p">)</span>
<span class="c1">;; prints in console:</span>
<span class="nv">-------------------------</span>
<span class="nv">clojure.core/map</span>
<span class="p">([</span><span class="nv">f</span> <span class="nv">coll</span><span class="p">]</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">c1</span> <span class="nv">c2</span><span class="p">]</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">c1</span> <span class="nv">c2</span> <span class="nv">c3</span><span class="p">]</span> <span class="p">[</span><span class="nv">f</span> <span class="nv">c1</span> <span class="nv">c2</span> <span class="nv">c3</span> <span class="o">&amp;</span> <span class="nv">colls</span><span class="p">])</span>
  <span class="nv">Returns</span> <span class="nv">a</span> <span class="nv">lazy</span> <span class="nv">sequence</span> <span class="nv">consisting</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">result</span> <span class="nv">of</span> <span class="nv">applying</span> <span class="nv">f</span> <span class="nv">to</span> <span class="nv">the</span>
  <span class="nb">set </span><span class="nv">of</span> <span class="nb">first </span><span class="nv">items</span> <span class="nv">of</span> <span class="nv">each</span> <span class="nv">coll</span>, <span class="nv">followed</span> <span class="nv">by</span> <span class="nv">applying</span> <span class="nv">f</span> <span class="nv">to</span> <span class="nv">the</span> <span class="nv">set</span>
  <span class="nv">of</span> <span class="nb">second </span><span class="nv">items</span> <span class="nv">in</span> <span class="nv">each</span> <span class="nv">coll</span>, <span class="nv">until</span> <span class="nv">any</span> <span class="nv">one</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">colls</span> <span class="nv">is</span>
  <span class="nv">exhausted.</span>  <span class="nv">Any</span> <span class="nv">remaining</span> <span class="nv">items</span> <span class="nv">in</span> <span class="nv">other</span> <span class="nv">colls</span> <span class="nv">are</span> <span class="nv">ignored.</span> <span class="nv">Function</span>
  <span class="nv">f</span> <span class="nv">should</span> <span class="nv">accept</span> <span class="nv">number-of-colls</span> <span class="nv">arguments.</span>

<span class="nv">=&gt;</span> <span class="p">(</span><span class="nb">doc </span><span class="nv">clojure.core</span><span class="p">)</span>
<span class="nv">-------------------------</span>
<span class="nv">clojure.core</span>
  <span class="nv">Fundamental</span> <span class="nv">library</span> <span class="nv">of</span> <span class="nv">the</span> <span class="nv">Clojure</span> <span class="nv">language</span>
</pre></div>
</div>
</div>
<span id="document-clojure.repl/find-doc"></span><div class="section" id="find-doc">
<h3>find-doc<a class="headerlink" href="#find-doc" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(find-doc re-string-or-pattern)</strong></div>
</div>
<p>如果某个Var对象的名字或者文档能与给定字符串或者正则表达式相匹配，那么打印该Var对象的文档信息。</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">find-doc </span><span class="s">&quot;data structure&quot;</span><span class="p">)</span>

<span class="nv">-------------------------</span>
<span class="nv">clojure.core/eval</span>
<span class="p">([</span><span class="nv">form</span><span class="p">])</span>
  <span class="nv">Evaluates</span> <span class="nv">the</span> <span class="nv">form</span> <span class="nv">data</span> <span class="nv">structure</span> <span class="p">(</span><span class="nb">not </span><span class="nv">text!</span><span class="p">)</span> <span class="nb">and </span><span class="nv">returns</span> <span class="nv">the</span> <span class="nv">result.</span>
<span class="nv">-------------------------</span>
<span class="nv">clojure.core/ifn?</span>
<span class="p">([</span><span class="nv">x</span><span class="p">])</span>
  <span class="nv">Returns</span> <span class="nv">true</span> <span class="k">if </span><span class="nv">x</span> <span class="nv">implements</span> <span class="nv">IFn.</span> <span class="nv">Note</span> <span class="nv">that</span> <span class="nv">many</span> <span class="nv">data</span> <span class="nv">structures</span>
  <span class="p">(</span><span class="nf">e.g.</span> <span class="nv">sets</span> <span class="nb">and </span><span class="nv">maps</span><span class="p">)</span> <span class="nv">implement</span> <span class="nv">IFn</span>
    <span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;clojure.string</span> <span class="ss">&#39;clojure.repl</span><span class="p">)</span>
<span class="nv">-------------------------</span>
<span class="nv">........</span>
</pre></div>
</div>
</div>
<span id="document-clojure.repl/pst"></span><div class="section" id="pst">
<h3>pst<a class="headerlink" href="#pst" title="永久链接至标题">¶</a></h3>
<div class="line-block">
<div class="line"><strong>(pst)</strong></div>
<div class="line"><strong>(pst e-or-depth)</strong></div>
<div class="line"><strong>(pst e depth)</strong></div>
</div>
<p>英文全称为print stack trace</p>
<p>打印出最近一次被REPL捕获的异常信息</p>
<div class="highlight-clojure"><div class="highlight"><pre><span class="nv">user=&gt;</span> <span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1">;; ArithmeticException Divide by zero  clojure.lang.Numbers.divide (Numbers.java:156)</span>

<span class="nv">user=&gt;</span> <span class="p">(</span><span class="nf">pst</span><span class="p">)</span>
<span class="c1">;; ArithmeticException Divide by zero</span>
<span class="c1">;;    clojure.lang.Numbers.divide (Numbers.java:156)</span>
<span class="c1">;;    clojure.lang.Numbers.divide (Numbers.java:3691)</span>
<span class="c1">;;    user/eval13 (NO_SOURCE_FILE:7)</span>
<span class="c1">;;    clojure.lang.Compiler.eval (Compiler.java:6619)</span>
<span class="c1">;;    clojure.lang.Compiler.eval (Compiler.java:6582)</span>
<span class="c1">;;    clojure.core/eval (core.clj:2852)</span>
<span class="c1">;;    clojure.main/repl/read-eval-print--6588/fn--6591 (main.clj:259)</span>
<span class="c1">;;    clojure.main/repl/read-eval-print--6588 (main.clj:259)</span>
<span class="c1">;;    clojure.main/repl/fn--6597 (main.clj:277)</span>
<span class="c1">;;    clojure.main/repl (main.clj:277)</span>
<span class="c1">;;    clojure.main/repl-opt (main.clj:343)</span>
<span class="c1">;;    clojure.main/main (main.clj:441)</span>
<span class="nv">nil</span>
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="id1">
<h2>参考资料<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>Clojure 官方文档： <a class="reference external" href="http://clojure.org/documentation">clojure.org/documentation</a></p>
<p>Clojure API 手册： <a class="reference external" href="http://clojure.github.com/clojure/">clojure.github.com/clojure</a></p>
<p>Clojure Cheat Sheet： <a class="reference external" href="http://clojure.org/cheatsheet">clojure.org/cheatsheet</a></p>
<p>ClojureDocs ，由社区驱动的，带代码示例的 API 手册： <a class="reference external" href="http://clojuredocs.org/">clojuredocs.org</a></p>
</div>
</div>


           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2007-2012 by Rich Hickey.
      
        <span class="commit">
          Revision <code>300c8b65</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
    <span class="rst-current-version" data-toggle="rst-current-version">
      <span class="fa fa-book"> Read the Docs</span>
      v: latest
      <span class="fa fa-caret-down"></span>
    </span>
    <div class="rst-other-versions">
      <dl>
        <dt>Versions</dt>
        
          <dd><a href="/zh_CN/latest/">latest</a></dd>
        
      </dl>
      <dl>
        <dt>Downloads</dt>
        
      </dl>
      <dl>
        <dt>On Read the Docs</dt>
          <dd>
            <a href="//readthedocs.org/projects/clojure-api-zh/?fromdocs=clojure-api-zh">Project Home</a>
          </dd>
          <dd>
            <a href="//readthedocs.org/builds/clojure-api-zh/?fromdocs=clojure-api-zh">Builds</a>
          </dd>
      </dl>
      <hr/>
      Free document hosting provided by <a href="http://www.readthedocs.org">Read the Docs</a>.

    </div>
  </div>



  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.4',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-2.0.3.min.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/jquery/jquery-migrate-1.2.1.min.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/underscore.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/doctools.js"></script>
      <script type="text/javascript" src="_static/translations.js"></script>
      <script type="text/javascript" src="https://media.readthedocs.org/javascript/readthedocs-doc-embed.js"></script>

  

  
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>